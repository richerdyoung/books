InnoDB的表空间
==========

标签： MySQL是怎样运行的

* * *

通过前边儿的内容大家知道，`表空间`是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为`表名.ibd`的实际文件。大家可以把表空间想象成被切分为许许多多个`页`的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。本章内容会深入到表空间的各个细节中，带领大家在`InnoDB`存储结构的池子中畅游。由于本章中将会涉及比较多的概念，虽然这些概念都不难，但是却相互依赖，所以奉劝大家在看的时候：

*   不要跳着看！
    
*   不要跳着看！
    
*   不要跳着看！
    

回忆一些旧知识
-------

### 页面类型

再一次强调，InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以`B+`树的形式保存到表空间的，而`B+`树的节点就是数据页。我们前边说过，这个数据页的类型名其实是：`FIL_PAGE_INDEX`，除了这种存放索引数据的页面类型之外，InnoDB也为了不同的目的设计了若干种不同类型的页面，为了唤醒大家的记忆，我们再一次把各种常用的页面类型提出来：

类型名称

十六进制

描述

`FIL_PAGE_TYPE_ALLOCATED`

0x0000

最新分配，还没使用

`FIL_PAGE_UNDO_LOG`

0x0002

Undo日志页

`FIL_PAGE_INODE`

0x0003

段信息节点

`FIL_PAGE_IBUF_FREE_LIST`

0x0004

Insert Buffer空闲列表

`FIL_PAGE_IBUF_BITMAP`

0x0005

Insert Buffer位图

`FIL_PAGE_TYPE_SYS`

0x0006

系统页

`FIL_PAGE_TYPE_TRX_SYS`

0x0007

事务系统数据

`FIL_PAGE_TYPE_FSP_HDR`

0x0008

表空间头部信息

`FIL_PAGE_TYPE_XDES`

0x0009

扩展描述页

`FIL_PAGE_TYPE_BLOB`

0x000A

BLOB页

`FIL_PAGE_INDEX`

0x45BF

索引页，也就是我们所说的`数据页`

因为页面类型前边都有个`FIL_PAGE`或者`FIL_PAGE_TYPE`的前缀，为简便起见我们后边唠叨页面类型的时候就把这些前缀省略掉了，比方说`FIL_PAGE_TYPE_ALLOCATED`类型称为`ALLOCATED`类型，`FIL_PAGE_INDEX`类型称为`INDEX`类型。

### 页面通用部分

我们前边说过数据页，也就是`INDEX`类型的页由7个部分组成，其中的两个部分是所有类型的页面都通用的。当然我不能寄希望于你把我说的话都记住，所以在这里重新强调一遍，任何类型的页面都有下边这种通用的结构：

![image_1crjupisqne61uer17ikh6l1v8k9.png-44.9kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="827" height="525"></svg>)

从上图中可以看出，任何类型的页都会包含这两个部分：

*   `File Header`：记录页面的一些通用信息
    
*   `File Trailer`：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。
    

对于`File Trailer`我们不再做过多强调，全部忘记了的话可以到将数据页的那一章回顾一下。我们这里再强调一遍`File Header`的各个组成部分：

名称

占用空间大小

描述

`FIL_PAGE_SPACE_OR_CHKSUM`

`4`字节

页的校验和（checksum值）

`FIL_PAGE_OFFSET`

`4`字节

页号

`FIL_PAGE_PREV`

`4`字节

上一个页的页号

`FIL_PAGE_NEXT`

`4`字节

下一个页的页号

`FIL_PAGE_LSN`

`8`字节

页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）

`FIL_PAGE_TYPE`

`2`字节

该页的类型

`FIL_PAGE_FILE_FLUSH_LSN`

`8`字节

仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值

`FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID`

`4`字节

页属于哪个表空间

现在除了名称里边儿带有`LSN`的两个字段大家可能看不懂以外，其他的字段肯定都是倍儿熟了，不过我们仍要强调这么几点：

*   表空间中的每一个页都对应着一个页号，也就是`FIL_PAGE_OFFSET`，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3...依此类推
    
*   某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了`INDEX`类型的页，也就是我们之前一直说的数据页建立`B+`树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。
    
*   每个页的类型由`FIL_PAGE_TYPE`表示，比如像数据页的该字段的值就是`0x45BF`，我们后边会介绍各种不同类型的页，不同类型的页在该字段上的值是不同的。
    

独立表空间结构
-------

我们知道`InnoDB`支持许多种类型的表空间，本章重点关注独立表空间和系统表空间的结构。它们的结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先挑简单一点的独立表空间来唠叨，稍后再说系统表空间的结构。

### 区（extent）的概念

表空间中的页实在是太多了，为了更好的管理这些页面，设计`InnoDB`的大叔们提出了`区`（英文名：`extent`）的概念。对于16KB的页来说，连续的64个页就是一个`区`，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：

![image_1cri1nutcorp5ghf5c7vqagt1j.png-71.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="662" height="547"></svg>)

其中`extent 0` ~ `extent 255`这256个区算是第一个组，`extent 256` ~ `extent 511`这256个区算是第二个组，`extent 512` ~ `extent 767`这256个区算是第三个组（上图中并未画全第三个组全部的区，请自行脑补），依此类推可以划分更多的组。这些组的头几个页面的类型都是类似的，就像这样：

![image_1crjo0hl4q8u1dkdofe187b10fa9.png-105.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="826" height="657"></svg>)

从上图中我们能得到如下信息：

*   第一个组最开始的3个页面的类型是固定的，也就是说`extent 0`这个区最开始的3个页面的类型是固定的，分别是：
    
    *   `FSP_HDR`类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的`区`，也就是`extent 0` ~ `extent 255`这256个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个`FSP_HDR`类型的页面。
        
    *   `IBUF_BITMAP`类型：这个类型的页面是存储本组所有的区的所有页面关于`INSERT BUFFER`的信息。当然，你现在不用知道啥是个`INSERT BUFFER`，后边会详细说到你吐。
        
    *   `INODE`类型：这个类型的页面存储了许多称为`INODE`的数据结构，还是那句话，现在你不需要知道啥是个`INODE`，后边儿会说到你吐。
        
*   其余各组最开始的2个页面的类型是固定的，也就是说`extent 256`、`extent 512`这些区最开始的2个页面的类型是固定的，分别是：
    
    *   `XDES`类型：全称是`extent descriptor`，用来登记本组256个区的属性，也就是说对于在`extent 256`区中的该类型页面存储的就是`extent 256` ~ `extent 511`这些区的属性，对于在`extent 512`区中的该类型页面存储的就是`extent 512` ~ `extent 767`这些区的属性。上边介绍的`FSP_HDR`类型的页面其实和`XDES`类型的页面的作用类似，只不过`FSP_HDR`类型的页面还会额外存储一些表空间的属性。
        
    *   `IBUF_BITMAP`类型：上边介绍过了。
        

好了，宏观的结构介绍完了，里边儿的名词大家也不用记清楚，只要大致记得：表空间被划分为许多连续的`区`，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了。

### 段（segment）的概念

为啥好端端的提出一个`区`（`extent`）的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里边儿，然后页作为节点组成`B+`树，这个`B+`树就是索引，然后吧啦吧啦一堆聚簇索引和二级索引的区别。这套路也没啥不妥的呀～

是的，如果我们表中数据量很少的话，比如说你的表中只有几十条、几百条数据的话，的确用不到`区`的概念，因为简单的几个页就能把对应的数据存储起来，但是你架不住表里的记录越来越多呀。

？？啥？？表里的记录多了又怎样？`B+`树的每一层中的页都会形成一个双向链表呀，`File Header`中的`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`字段不就是为了形成双向链表设置的么？

是的是的，您说的都对，从理论上说，不引入`区`的概念只使用`页`的概念对存储引擎的运行并没啥影响，但是我们来考虑一下下边这个场景：

*   我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的`B+`树的节点中插入数据。而`B+`树的每一层中的页都会形成一个双向链表，如果是以`页`为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍`B+`树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的`随机I/O`。再一次强调，磁盘的速度和内存的速度差了好几个数量级，`随机I/O`是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的`顺序I/O`。

所以，所以，所以才引入了`区`（`extent`）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照`区`为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机`I/O`，功大于过嘛！

事情到这里就结束了么？太天真了，我们提到的范围查询，其实是对`B+`树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以设计`InnoDB`的大叔们对`B+`树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的`区`，非叶子节点也有自己独有的`区`。存放叶子节点的区的集合就算是一个`段`（`segment`），存放非叶子节点的区的集合也算是一个`段`。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

默认情况下一个使用`InnoDB`存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计`InnoDB`的大叔们都挺节俭的，当然也考虑到了这种情况。这个问题的症结在于到现在为止我们介绍的区都是非常`纯粹`的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计`InnoDB`的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：

*   在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
    
*   当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。
    

所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，`InnoDB`中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。

### 区的分类

通过上边一通唠叨，大家知道了表空间的是由若干个区组成的，这些区大体上可以分为4种类型：

*   空闲的区：现在还没有用到这个区中的任何页面。
    
*   有剩余空间的碎片区：表示碎片区中还有可用的页面。
    
*   没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
    
*   附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。
    

这4种类型的区也可以被称为区的4种状态（`State`），设计`InnoDB`的大叔们为这4种状态的区定义了特定的名词儿：

状态名

含义

`FREE`

空闲的区

`FREE_FRAG`

有剩余空间的碎片区

`FULL_FRAG`

没有剩余空间的碎片区

`FSEG`

附属于某个段的区

需要再次强调一遍的是，处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，算是直属于表空间；而处于`FSEG`状态的区是附属于某个段的。

> 小贴士： 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于\`FSEG\`的区全都隶属于某个段，而处于\`FREE\`、\`FREE\_FRAG\`以及\`FULL\_FRAG\`这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。

为了方便管理这些区，设计`InnoDB`的大叔设计了一个称为`XDES Entry`的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个`XDES Entry`结构，这个结构记录了对应的区的一些属性。我们先看图来对这个结构有个大致的了解：

![image_1crre79uq9971bsdj9s1i0j11en8a.png-96.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1086" height="473"></svg>)

从图中我们可以看出，`XDES Entry`是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：

*   `Segment ID`（8字节）
    
    每一个段都有一个唯一的编号，用ID表示，此处的`Segment ID`字段表示就是该区所在的段。当然前提是该区已经被分配给某个段了，不然的话该字段的值没啥意义。
    
*   `List Node`（12字节）
    
    这个部分可以将若干个`XDES Entry`结构串联成一个链表，大家看一下这个`List Node`的结构：
    
    ![image_1crre8tlh1vmqtfipk663l173q97.png-69.1kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="694" height="345"></svg>)
    
    如果我们想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。所以：
    
    *   `Pre Node Page Number`和`Pre Node Offset`的组合就是指向前一个`XDES Entry`的指针
        
    *   `Next Node Page Number`和`Next Node Offset`的组合就是指向后一个`XDES Entry`的指针。
        
    
    把一些`XDES Entry`结构连成一个链表有啥用？稍安勿躁，我们稍后唠叨`XDES Entry`结构组成的链表问题。
    
*   `State`（4字节）
    
    这个字段表明区的状态。可选的值就是我们前边说过的那4个，分别是：`FREE`、`FREE_FRAG`、`FULL_FRAG`和`FSEG`。具体释义就不多唠叨了，前边说的够仔细了。
    
*   `Page State Bitmap`（16字节）
    
    这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。比如`Page State Bitmap`部分的第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推，`Page State Bitmap`部分的第127和128个比特位对应着区中的第64个页面。这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。
    

#### XDES Entry链表

到现在为止，我们已经提出了五花八门的概念，什么区、段、碎片区、附属于段的区、`XDES Entry`结构吧啦吧啦的概念，走远了千万别忘了自己为什么出发，我们把事情搞这么麻烦的初心仅仅是想提高向表插入数据的效率又不至于数据量少的表浪费空间。现在我们知道向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程：

*   当段中数据较少的时候，首先会查看表空间中是否有状态为`FREE_FRAG`的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零碎的页把数据插进去；否则到表空间下申请一个状态为`FREE`的区，也就是空闲的区，把该区的状态变为`FREE_FRAG`，然后从该新申请的区中取一些零碎的页把数据插进去。之后不同的段使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了`FULL_FRAG`。
    
    现在的问题是你怎么知道表空间里的哪些区是`FREE`的，哪些区的状态是`FREE_FRAG`的，哪些区是`FULL_FRAG`的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，我们总不能每次都遍历这些区对应的`XDES Entry`结构吧？这时候就是`XDES Entry`中的`List Node`部分发挥奇效的时候了，我们可以通过`List Node`中的指针，做这么三件事：
    
    *   把状态为`FREE`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表我们就称之为`FREE`链表。
        
    *   把状态为`FREE_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表我们就称之为`FREE_FRAG`链表。
        
    *   把状态为`FULL_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表我们就称之为`FULL_FRAG`链表。
        
    
    这样每当我们想找一个`FREE_FRAG`状态的区时，就直接把`FREE_FRAG`链表的头节点拿出来，从这个节点中取一些零碎的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的`State`字段的值，然后从`FREE_FRAG`链表中移到`FULL_FRAG`链表中。同理，如果`FREE_FRAG`链表中一个节点都没有，那么就直接从`FREE`链表中取一个节点移动到`FREE_FRAG`链表的状态，并修改该节点的`STATE`字段值为`FREE_FRAG`，然后从这个节点对应的区中获取零碎的页就好了。
    
*   当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据了。
    
    还是那个问题，我们怎么知道哪些区属于哪个段的呢？再遍历各个`XDES Entry`结构？遍历是不可能遍历的，这辈子都不可能遍历的，有链表还遍历个毛线啊。所以我们把状态为`FSEG`的区对应的`XDES Entry`结构都加入到一个链表喽？傻呀，不同的段哪能共用一个区呢？你想把索引a的叶子节点段和索引b的叶子节点段都存储到一个区中么？显然我们想要每个段都有它独立的链表，所以可以根据段号（也就是`Segment ID`）来建立链表，有多少个段就建多少个链表？好像也有点问题，因为一个段中可以有好多个区，有的区是完全空闲的，有的区还有一些页面可以用，有的区已经没有空闲页面可以用了，所以我们有必要继续细分，设计`InnoDB`的大叔们为每个段中的区对应的`XDES Entry`结构建立了三个链表：
    
    *   `FREE`链表：同一个段中，所有页面都是空闲的区对应的`XDES Entry`结构会被加入到这个链表。注意和直属于表空间的`FREE`链表区别开了，此处的`FREE`链表是附属于某个段的。
        
    *   `NOT_FULL`链表：同一个段中，仍有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表。
        
    *   `FULL`链表：同一个段中，已经没有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表。
        
    
    再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表，比如下边这个表：
    
        CREATE TABLE t (
            c1 INT NOT NULL AUTO_INCREMENT,
            c2 VARCHAR(100),
            c3 VARCHAR(100),
            PRIMARY KEY (c1),
            KEY idx_c2 (c2)
        )ENGINE=InnoDB;
        
    
    这个表`t`共有两个索引，一个聚簇索引，一个二级索引`idx_c2`，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表，加上我们上边说过的直属于表空间的3个链表，整个独立表空间共需要维护15个链表。所以段在数据量比较大时插入数据的话，会先获取`NOT_FULL`链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到`FULL`链表中。
    

#### 链表基节点

上边光是介绍了一堆链表，可我们怎么找到这些链表呢，或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？设计`InnoDB`的大叔当然考虑了这个问题，他们设计了一个叫`List Base Node`的结构，翻译成中文就是链表的基节点。这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息，我们画图看一下这个结构的示意图：

![image_1crrehf6i1jsq1j5cubj1mdoh77a4.png-81.6kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="777" height="451"></svg>)

我们上边介绍的每个链表都对应这么一个`List Base Node`结构，其中：

*   `List Length`表明该链表一共有多少节点，
    
*   `First Node Page Number`和`First Node Offset`表明该链表的头节点在表空间中的位置。
    
*   `Last Node Page Number`和`Last Node Offset`表明该链表的尾节点在表空间中的位置。
    

一般我们把某个链表对应的`List Base Node`结构放置在表空间中固定的位置，这样想找定位某个链表就变得so easy啦。

#### 链表小结

综上所述，表空间是由若干个区组成的，每个区都对应一个`XDES Entry`的结构，直属于表空间的区对应的`XDES Entry`结构可以分成`FREE`、`FREE_FRAG`和`FULL_FRAG`这3个链表；每个段可以附属若干个区，每个段中的区对应的`XDES Entry`结构可以分成`FREE`、`NOT_FULL`和`FULL`这3个链表。每个链表都对应一个`List Base Node`的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。

### 段的结构

我们前边说过，段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区都有对应的`XDES Entry`来记录这个区中的属性一样，设计`InnoDB`的大叔为每个段都定义了一个`INODE Entry`结构来记录一下段中的属性。大家看一下示意图：

![image_1crrju0cnji91a2fhv91ijb15hgb1.png-111.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="863" height="535"></svg>)

它的各个部分释义如下：

*   `Segment ID`
    
    就是指这个`INODE Entry`结构对应的段的编号（ID）。
    
*   `NOT_FULL_N_USED`
    
    这个字段指的是在`NOT_FULL`链表中已经使用了多少个页面。下次从`NOT_FULL`链表分配空闲页面时可以直接根据这个字段的值定位到。而不用从链表中的第一个页面开始遍历着寻找空闲页面。
    
*   3个`List Base Node`
    
    分别为段的`FREE`链表、`NOT_FULL`链表、`FULL`链表定义了`List Base Node`，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的`List Base Node`。so easy!
    
*   `Magic Number`：
    
    这个值是用来标记这个`INODE Entry`是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的`97937874`，表明该`INODE Entry`已经初始化，否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。
    
*   `Fragment Array Entry`
    
    我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个`Fragment Array Entry`结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。
    

结合着这个`INODE Entry`结构，大家可能对段是一些零散页面和一些完整的区的集合的理解再次深刻一些。

### 各类型页面详细情况

到现在为止我们已经大概清楚了表空间、段、区、XDES Entry、INODE Entry、各种以`XDES Enty`为节点的链表的基本概念了，可是总有一种飞在天上不踏实的感觉，每个区对应的`XDES Entry`结构到底存储在表空间的什么地方？直属于表空间的`FREE`、`FREE_FRAG`、`FULL_FRAG`链表的基节点到底存储在表空间的什么地方？每个段对应的`INODE Entry`结构到底存在表空间的什么地方？我们前边介绍了每256个连续的区算是一个组，想解决刚才提出来的这些个疑问还得从每个组开头的一些类型相同的页面说起，接下来我们一个页面一个页面的分析，真相马上就要浮出水面了。

#### `FSP_HDR`类型

首先看第一个组的第一个页面，当然也是表空间的第一个页面，页号为`0`。这个页面的类型是`FSP_HDR`，它存储了表空间的一些整体属性以及第一个组内256个区的对应的`XDES Entry`结构，直接看这个类型的页面的示意图：

![image_1crmfvigk938c8h1hahglr15329.png-146.8kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1136" height="553"></svg>)

从图中可以看出，一个完整的`FSP_HDR`类型的页面大致由5个部分组成，各个部分的具体释义如下表：

名称

中文名

占用空间大小

简单描述

`File Header`

文件头部

`38`字节

页的一些通用信息

`File Space Header`

表空间头部

`112`字节

表空间的一些整体属性信息

`XDES Entry`

区描述信息

`10240`字节

存储本组256个区对应的属性信息

`Empty Space`

尚未使用空间

`5986`字节

用于页结构的填充，没啥实际意义

`File Trailer`

文件尾部

`8`字节

校验页是否完整

`File Header`和`File Trailer`就不再强调了，另外的几个部分中，`Empty Space`是尚未使用的空间，我们不用管它，重点来看看`File Space Header`和`XDES Entry`这两个部分。

##### File Space Header部分

从名字就可以看出来，这个部分是用来存储表空间的一些整体属性的，废话少说，看图：

![image_1crrp2qp310rc10fd33ch716hcp.png-148.1kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="912" height="557"></svg>)

哇唔，字段有点儿多哦，不急一个一个慢慢看。下面是各个属性的简单描述：

名称

占用空间大小

描述

`Space ID`

`4`字节

表空间的ID

`Not Used`

`4`字节

这4个字节未被使用，可以忽略

`Size`

`4`字节

当前表空间占有的页面数

`FREE Limit`

`4`字节

尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表

`Space Flags`

`4`字节

表空间的一些占用存储空间比较小的属性

`FRAG_N_USED`

`4`字节

FREE_FRAG链表中已使用的页面数量

`List Base Node for FREE List`

`16`字节

FREE链表的基节点

`List Base Node for FREE_FRAG List`

`16`字节

FREE_FRAG链表的基节点

`List Base Node for FULL_FRAG List`

`16`字节

FULL_FRAG链表的基节点

`Next Unused Segment ID`

`8`字节

当前表空间中下一个未使用的 Segment ID

`List Base Node for SEG_INODES_FULL List`

`16`字节

SEG\_INODES\_FULL链表的基节点

`List Base Node for SEG_INODES_FREE List`

`16`字节

SEG\_INODES\_FREE链表的基节点

这里头的`Space ID`、`Not Used`、`Size`这三个字段大家肯定一看就懂，其他的字段我们再详细瞅瞅，为了大家的阅读体验，我就不严格按照实际的字段顺序来解释各个字段了哈。

*   `List Base Node for FREE List`、`List Base Node for FREE_FRAG List`、`List Base Node for FULL_FRAG List`。
    
    这三个大家看着太亲切了，分别是直属于表空间的`FREE`链表的基节点、`FREE_FRAG`链表的基节点、`FULL_FRAG`链表的基节点，这三个链表的基节点在表空间的位置是固定的，就是在表空间的第一个页面（也就是`FSP_HDR`类型的页面）的`File Space Header`部分。所以之后定位这几个链表就so easy啦。
    
*   `FRAG_N_USED`
    
    这个字段表明在`FREE_FRAG`链表中已经使用的页面数量，方便之后在链表中查找空闲的页面。
    
*   `FREE Limit`
    
    我们知道表空间都对应着具体的磁盘文件，一开始我们创建表空间的时候对应的磁盘文件中都没有数据，所以我们需要对表空间完成一个初始化操作，包括为表空间中的区建立`XDES Entry`结构，为各个段建立`INODE Entry`结构，建立各种链表吧啦吧啦的各种操作。我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的`XDES Entry`结构加入`FREE`链表，也可以选择只把一部分的空闲区加入`FREE`链表，等啥时候空闲链表中的`XDES Entry`结构对应的区不够使了，再把之前没有加入`FREE`链表的空闲区对应的`XDES Entry`结构加入`FREE`链表，中心思想就是啥时候用到啥时候初始化，设计`InnoDB`的大叔采用的就是后者，他们为表空间定义了`FREE Limit`这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。
    
*   `Next Unused Segment ID`
    
    表中每个索引都对应2个段，每个段都有一个唯一的ID，那当我们为某个表新创建一个索引的时候，就意味着要创建两个新的段。那怎么为这个新创建的段找一个唯一的ID呢？去遍历现在表空间中所有的段么？我们说过，遍历是不可能遍历的，这辈子都不可能遍历，所以设计`InnoDB`的大叔们提出了这个名叫`Next Unused Segment ID`的字段，该字段表明当前表空间中最大的段ID的下一个ID，这样在创建新段的时候赋予新段一个唯一的ID值就so easy啦，直接使用这个字段的值就好了。
    
*   `Space Flags`
    
    表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个`Space Flags`中存储，虽然它只有4个字节，32个比特位大小，却存储了好多表空间的属性，详细情况如下表：
    
    标志名称
    
    占用的空间（单位：bit）
    
    描述
    
    `POST_ANTELOPE`
    
    1
    
    表示文件格式是否大于`ANTELOPE`
    
    `ZIP_SSIZE`
    
    4
    
    表示压缩页面的大小
    
    `ATOMIC_BLOBS`
    
    1
    
    表示是否自动把值非常长的字段放到BLOB页里
    
    `PAGE_SSIZE`
    
    4
    
    页面大小
    
    `DATA_DIR`
    
    1
    
    表示表空间是否是从默认的数据目录中获取的
    
    `SHARED`
    
    1
    
    是否为共享表空间
    
    `TEMPORARY`
    
    1
    
    是否为临时表空间
    
    `ENCRYPTION`
    
    1
    
    表空间是否加密
    
    `UNUSED`
    
    18
    
    没有使用到的比特位
    
    > 小贴士： 不同MySQL版本里 SPACE\_FLAGS 代表的属性可能有些差异，我们这里列举的是5.7.21版本的。不过大家现在不必深究它们的意思，因为我们一旦把这些概念展开，就需要非常大的篇幅，主要怕大家受不了。我们还是先挑重要的看，把主要的表空间结构了解完，这些 SPACE\_FLAGS 里的属性的细节就暂时不深究了。
    
*   `List Base Node for SEG_INODES_FULL List`和`List Base Node for SEG_INODES_FREE List`
    
    每个段对应的`INODE Entry`结构会集中存放到一个类型位`INODE`的页中，如果表空间中的段特别多，则会有多个`INODE Entry`结构，可能一个页放不下，这些`INODE`类型的页会组成两种列表：
    
    *   `SEG_INODES_FULL`链表，该链表中的`INODE`类型的页面都已经被`INODE Entry`结构填充满了，没空闲空间存放额外的`INODE Entry`了。
        
    *   `SEG_INODES_FREE`链表，该链表中的`INODE`类型的页面仍有空闲空间来存放`INODE Entry`结构。
        
    
    由于我们现在还没有详细唠叨`INODE`类型页，所以等会说过`INODE`类型的页之后再回过头来看着两个链表。
    

##### XDES Entry部分

紧接着`File Space Header`部分的就是`XDES Entry`部分了，我们嘴上唠叨过无数次，却从没见过真身的`XDES Entry`就是在表空间的第一个页面中保存的。我们知道一个`XDES Entry`结构的大小是40字节，但是一个页面的大小有限，只能存放有限个`XDES Entry`结构，所以我们才把256个区划分成一组，在每组的第一个页面中存放256个`XDES Entry`结构。大家回看那个`FSP_HDR`类型页面的示意图，`XDES Entry 0`就对应着`extent 0`，`XDES Entry 1`就对应着`extent 1`... 依此类推，`XDES Entry255`就对应着`extent 255`。

因为每个区对应的`XDES Entry`结构的地址是固定的，所以我们访问这些结构就so easy啦，至于该结构的详细使用情况我们已经唠叨的够明白了，在这就不赘述了。

#### `XDES`类型

我们说过，每一个`XDES Entry`结构对应表空间的一个区，虽然一个`XDES Entry`结构只占用40字节，但你抵不住表空间的区的数量也多啊。在区的数量非常多时，一个单独的页可能就不够存放足够多的`XDES Entry`结构，所以我们把表空间的区分为了若干个组，每组开头的一个页面记录着本组内所有的区对应的`XDES Entry`结构。由于第一个组的第一个页面有些特殊，因为它也是整个表空间的第一个页面，所以除了记录本组中的所有区对应的`XDES Entry`结构以外，还记录着表空间的一些整体属性，这个页面的类型就是我们刚刚说完的`FSP_HDR`类型，整个表空间里只有一个这个类型的页面。除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的`XDES Entry`结构即可，不需要再记录表空间的属性了，为了和`FSP_HDR`类型做区别，我们把之后每个分组的第一个页面的类型定义为`XDES`，它的结构和`FSP_HDR`类型是非常相似的：

![image_1cs3vmoii1h971aje1iveack1l109.png-149.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1257" height="599"></svg>)

与`FSP_HDR`类型的页面对比，除了少了`File Space Header`部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样一样的。由于我们上边唠叨的已经够仔细了，对于`XDES`类型的页面也就不重复唠叨了哈。

#### `IBUF_BITMAP`类型

对比前边介绍表空间的图，每个分组的第二个页面的类型都是`IBUF_BITMAP`，这种类型的页里边记录了一些有关`Change Buffer`的东东，由于这个`Change Buffer`里又包含了贼多的概念，考虑到大家在一章中接受这么多新概念有点呼吸不适，怕大家心脏病犯了所以就把`Change Buffer`的相关知识放到后边的章节中，大家稍安勿躁哈。

#### `INODE`类型

再次对比前边介绍表空间的图，第一个分组的第三个页面的类型是`INODE`。我们前边说过设计`InnoDB`的大叔为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个`INODE Entry`结构，这个结构中记录了关于这个段的相关属性。而我们这会儿要介绍的这个`INODE`类型的页就是为了存储`INODE Entry`结构而存在的。好了，废话少说，直接看图：

![image_1d6dlre5mv9sptarvdi68mp8p.png-162.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1150" height="539"></svg>)

从图中可以看出，一个`INODE`类型的页面是由这几部分构成的：

名称

中文名

占用空间大小

简单描述

`File Header`

文件头部

`38`字节

页的一些通用信息

`List Node for INODE Page List`

通用链表节点

`12`字节

存储上一个INODE页面和下一个INODE页面的指针

`INODE Entry`

段描述信息

`16128`字节

`Empty Space`

尚未使用空间

`6`字节

用于页结构的填充，没啥实际意义

`File Trailer`

文件尾部

`8`字节

校验页是否完整

除了`File Header`、`Empty Space`、`File Trailer`这几个老朋友外，我们重点关注`List Node for INODE Page List`和`INODE Entry`这两个部分。

首先看`INODE Entry`部分，我们前边已经详细介绍过这个结构的组成了，主要包括对应的段内零散页面的地址以及附属于该段的`FREE`、`NOT_FULL`和`FULL`链表的基节点。每个`INODE Entry`结构占用192字节，一个页面里可以存储`85`个这样的结构。

重点看一下`List Node for INODE Page List`这个玩意儿，因为一个表空间中可能存在超过85个段，所以可能一个`INODE`类型的页面不足以存储所有的段对应的`INODE Entry`结构，所以就需要额外的`INODE`类型的页面来存储这些结构。还是为了方便管理这些`INODE`类型的页面，设计`InnoDB`的大叔们将这些`INODE`类型的页面串联成两个不同的链表：

*   `SEG_INODES_FULL`链表：该链表中的`INODE`类型的页面中已经没有空闲空间来存储额外的`INODE Entry`结构了。
    
*   `SEG_INODES_FREE`链表：该链表中的`INODE`类型的页面中还有空闲空间来存储额外的`INODE Entry`结构了。
    

想必大家已经认出这两个链表了，我们前边提到过这两个链表的基节点就存储在`File Space Header`里边，也就是说这两个链表的基节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以后每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个`INODE Entry`结构与之对应，存储`INODE Entry`的大致过程就是这样的：

*   先看看`SEG_INODES_FREE`链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的`INODE`类型的页面，然后把该`INODE Entry`结构放到该页面中。当该页面中无剩余空间时，就把该页放到`SEG_INODES_FULL`链表中。
    
*   如果`SEG_INODES_FREE`链表为空，则需要从表空间的`FREE_FRAG`链表中申请一个页面，修改该页面的类型为`INODE`，把该页面放到`SEG_INODES_FREE`链表中，与此同时把该`INODE Entry`结构放入该页面。
    

### Segment Header 结构的运用

我们知道一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个`INODE Entry`结构，那我们怎么知道某个段对应哪个`INODE Entry`结构呢？所以得找个地方记下来这个对应关系。希望你还记得我们在唠叨数据页，也就是`INDEX`类型的页时有一个`Page Header`部分，当然我不能指望你记住，所以把`Page Header`部分再抄一遍给你看：

**Page Header部分**（为突出重点，省略了好多属性）

名称

占用空间大小

描述

...

...

...

`PAGE_BTR_SEG_LEAF`

`10`字节

B+树叶子段的头部信息，仅在B+树的根页定义

`PAGE_BTR_SEG_TOP`

`10`字节

B+树非叶子段的头部信息，仅在B+树的根页定义

其中的`PAGE_BTR_SEG_LEAF`和`PAGE_BTR_SEG_TOP`都占用10个字节，它们其实对应一个叫`Segment Header`的结构，该结构图示如下：

![image_1d6a74gu41fuqcqm1htri771d1k16.png-65.1kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="657" height="326"></svg>)

各个部分的具体释义如下：

名称

占用字节数

描述

`Space ID of the INODE Entry`

`4`

INODE Entry结构所在的表空间ID

`Page Number of the INODE Entry`

`4`

INODE Entry结构所在的页面页号

`Byte Offset of the INODE Ent`

`2`

INODE Entry结构在该页面中的偏移量

这样子就很清晰了，`PAGE_BTR_SEG_LEAF`记录着叶子节点段对应的`INODE Entry`结构的地址是哪个表空间的哪个页面的哪个偏移量，`PAGE_BTR_SEG_TOP`记录着非叶子节点段对应的`INODE Entry`结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可。

### 真实表空间对应的文件大小

等会儿等会儿，上边的这些概念已经压的快喘不过气了。不过独立表空间有那么大么？我到数据目录里看了，一个新建的表对应的`.ibd`文件只占用了96K，才6个页面大小，上边的内容该不是扯犊子吧？

哈，一开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些`.ibd`文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

系统表空间
-----

了解完了独立表空间的基本结构，系统表空间的结构也就好理解多了，系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的`表空间 ID`（Space ID）是`0`。

### 系统表空间的整体结构

系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面，如图：

![image_1csbied27ohe1rgg32gquulplm.png-147.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="824" height="711"></svg>)

可以看到，系统表空间和独立表空间的前三个页面（页号分别为`0`、`1`、`2`，类型分别是`FSP_HDR`、`IBUF_BITMAP`、`INODE`）的类型是一致的，只是页号为`3`～`7`的页面是系统表空间特有的，我们来看一下这些多出来的页面都是干啥使的：

页号

页面类型

英文描述

描述

`3`

`SYS`

Insert Buffer Header

存储Insert Buffer的头部信息

`4`

`INDEX`

Insert Buffer Root

存储Insert Buffer的根页面

`5`

`TRX_SYS`

Transction System

事务系统的相关信息

`6`

`SYS`

First Rollback Segment

第一个回滚段的页面

`7`

`SYS`

Data Dictionary Header

数据字典头部信息

除了这几个记录系统属性的页面之外，系统表空间的`extent 1`和`extent 2`这两个区，也就是页号从`64`~`191`这128个页面被称为`Doublewrite buffer`，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，这些问题我们会放在后边的章节集中唠叨，现在讲述太影响用户体验，所以现在我们只唠叨一下有关InnoDB数据字典的知识，其余的概念在后边再看。

#### InnoDB数据字典

我们平时使用`INSERT`语句向表中插入的那些记录称之为用户数据，MySQL只是作为一个软件来为我们来保管这些数据，提供方便的增删改查接口而已。但是每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的`B+`树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：

*   某个表属于哪个表空间，表里边有多少列
    
*   表对应的每一个列的类型是什么
    
*   该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面
    
*   该表有哪些外键，外键对应哪个表的哪些列
    
*   某个表空间对应文件系统上文件路径是什么
    
*   balabala ... 还有好多，不一一列举了
    

上述这些数据并不是我们使用`INSERT`语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为`元数据`。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些`元数据`：

表名

描述

`SYS_TABLES`

整个InnoDB存储引擎中所有的表的信息

`SYS_COLUMNS`

整个InnoDB存储引擎中所有的列的信息

`SYS_INDEXES`

整个InnoDB存储引擎中所有的索引的信息

`SYS_FIELDS`

整个InnoDB存储引擎中所有的索引对应的列的信息

`SYS_FOREIGN`

整个InnoDB存储引擎中所有的外键的信息

`SYS_FOREIGN_COLS`

整个InnoDB存储引擎中所有的外键对应列的信息

`SYS_TABLESPACES`

整个InnoDB存储引擎中所有的表空间信息

`SYS_DATAFILES`

整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息

`SYS_VIRTUAL`

整个InnoDB存储引擎中所有的虚拟生成列的信息

这些系统表也被称为`数据字典`，它们都是以`B+`树的形式保存在系统表空间的某些页面中，其中`SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS`这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：

##### SYS_TABLES表

**SYS_TABLES表的列**

列名

描述

`NAME`

表的名称

`ID`

InnoDB存储引擎中每个表都有一个唯一的ID

`N_COLS`

该表拥有列的个数

`TYPE`

表的类型，记录了一些文件格式、行格式、压缩等信息

`MIX_ID`

已过时，忽略

`MIX_LEN`

表的一些额外的属性

`CLUSTER_ID`

未使用，忽略

`SPACE`

该表所属表空间的ID

这个`SYS_TABLES`表有两个索引：

*   以`NAME`列为主键的聚簇索引
    
*   以`ID`列建立的二级索引
    

##### SYS_COLUMNS表

**SYS_COLUMNS表的列**

列名

描述

`TABLE_ID`

该列所属表对应的ID

`POS`

该列在表中是第几列

`NAME`

该列的名称

`MTYPE`

main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东

`PRTYPE`

precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的

`LEN`

该列最多占用存储空间的字节数

`PREC`

该列的精度，不过这列貌似都没有使用，默认值都是0

这个`SYS_COLUMNS`表只有一个聚集索引：

*   以`(TABLE_ID, POS)`列为主键的聚簇索引

##### SYS_INDEXES表

**SYS_INDEXES表的列**

列名

描述

`TABLE_ID`

该索引所属表对应的ID

`ID`

InnoDB存储引擎中每个索引都有一个唯一的ID

`NAME`

该索引的名称

`N_FIELDS`

该索引包含列的个数

`TYPE`

该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型

`SPACE`

该索引根页面所在的表空间ID

`PAGE_NO`

该索引根页面所在的页面号

`MERGE_THRESHOLD`

如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例

这个`SYS_INEXES`表只有一个聚集索引：

*   以`(TABLE_ID, ID)`列为主键的聚簇索引

##### SYS_FIELDS表

**SYS_FIELDS表的列**

列名

描述

`INDEX_ID`

该索引列所属的索引的ID

`POS`

该索引列在某个索引中是第几列

`COL_NAME`

该索引列的名称

这个`SYS_INEXES`表只有一个聚集索引：

*   以`(INDEX_ID, POS)`列为主键的聚簇索引

##### Data Dictionary Header页面

只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看`SYS_TABLESPACES`这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：

*   到`SYS_TABLES`表中根据表名定位到具体的记录，就可以获取到`SYS_TABLESPACES`表的`TABLE_ID`
    
*   使用这个`TABLE_ID`到`SYS_COLUMNS`表中就可以获取到属于该表的所有列的信息。
    
*   使用这个`TABLE_ID`还可以到`SYS_INDEXES`表中获取所有的索引的信息，索引的信息中包括对应的`INDEX_ID`，还记录着该索引对应的`B+`数根页面是哪个表空间的哪个页面。
    
*   使用`INDEX_ID`就可以到`SYS_FIELDS`表中获取所有索引列的信息。
    

也就是说这4个表是表中之表，那这4个表的元数据去哪里获取呢？没法搞了，只能把这4个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，然后设计`InnoDB`的大叔又拿出一个固定的页面来记录这4个表的聚簇索引和二级索引对应的`B+树`位置，这个页面就是页号为`7`的页面，类型为`SYS`，记录了`Data Dictionary Header`，也就是数据字典的头部信息。除了这4个表的5个索引的根页面信息外，这个页号为`7`的页面还记录了整个InnoDB存储引擎的一些全局属性，说话太啰嗦，直接看这个页面的示意图：

![image_1d6a738dco0sugm14v4ivr1dnnp.png-206.9kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1154" height="628"></svg>)

可以看到这个页面由下边几个部分组成：

名称

中文名

占用空间大小

简单描述

`File Header`

文件头部

`38`字节

页的一些通用信息

`Data Dictionary Header`

数据字典头部信息

`56`字节

记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息

`Segment Header`

段头部信息

`10`字节

记录本页面所在段对应的INODE Entry位置信息

`Empty Space`

尚未使用空间

`16272`字节

用于页结构的填充，没啥实际意义

`File Trailer`

文件尾部

`8`字节

校验页是否完整

可以看到这个页面里竟然有`Segment Header`部分，意味着设计InnoDB的大叔把这些有关数据字典的信息当成一个段来分配存储空间，我们就姑且称之为`数据字典段`吧。由于目前我们需要记录的数据字典信息非常少（可以看到`Data Dictionary Header`部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为`7`的这个页。

接下来我们需要细细唠叨一下`Data Dictionary Header`部分的各个字段：

*   `Max Row ID`：我们说过如果我们不显式的为表定义主键，而且表中也没有`UNIQUE`索引，那么`InnoDB`存储引擎会默认为我们生成一个名为`row_id`的列作为主键。因为它是主键，所以每条记录的`row_id`列的值不能重复。原则上只要一个表中的`row_id`列不重复就可以了，也就是说表a和表b拥有一样的`row_id`列也没啥关系，不过设计InnoDB的大叔只提供了这个`Max Row ID`字段，不论哪个拥有`row_id`列的表插入一条记录时，该记录的`row_id`列的值就是`Max Row ID`对应的值，然后再把`Max Row ID`对应的值加1，也就是说这个`Max Row ID`是全局共享的。
    
*   `Max Table ID`：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。
    
*   `Max Index ID`：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。
    
*   `Max Space ID`：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。
    
*   `Mix ID Low(Unused)`：这个字段没啥用，跳过。
    
*   `Root of SYS_TABLES clust index`：本字段代表`SYS_TABLES`表聚簇索引的根页面的页号。
    
*   `Root of SYS_TABLE_IDS sec index`：本字段代表`SYS_TABLES`表为`ID`列建立的二级索引的根页面的页号。
    
*   `Root of SYS_COLUMNS clust index`：本字段代表`SYS_COLUMNS`表聚簇索引的根页面的页号。
    
*   `Root of SYS_INDEXES clust index`本字段代表`SYS_INDEXES`表聚簇索引的根页面的单表访问方法
======

标签： MySQL是怎样运行的

* * *

对于我们这些`MySQL`的使用者来说，`MySQL`其实就是一个软件，平时用的最多的就是查询功能。DBA时不时丢过来一些慢查询语句让优化，我们如果连查询是怎么执行的都不清楚还优化个毛线，所以是时候掌握真正的技术了。我们在第一章的时候就曾说过，`MySQL Server`有一个称为`查询优化器`的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的`执行计划`，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。不过查询优化这个主题有点儿大，在学会跑之前还得先学会走，所以本章先来瞅瞅`MySQL`怎么执行单表查询（就是`FROM`子句后边只有一个表，最简单的那种查询～）。不过需要强调的一点是，在学习本章前务必看过前边关于记录结构、数据页结构以及索引的部分，如果你不能保证这些东西已经完全掌握，那么本章不适合你。

为了故事的顺利发展，我们先得有个表：

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;
    

我们为这个`single_table`表建立了1个聚簇索引和4个二级索引，分别是：

*   为`id`列建立的聚簇索引。
    
*   为`key1`列建立的`idx_key1`二级索引。
    
*   为`key2`列建立的`idx_key2`二级索引，而且该索引是唯一二级索引。
    
*   为`key3`列建立的`idx_key3`二级索引。
    
*   为`key_part1`、`key_part2`、`key_part3`列建立的`idx_key_part`二级索引，这也是一个联合索引。
    

然后我们需要为这个表插入10000行记录，除`id`列外其余的列都插入随机值就好了，具体的插入语句我就不写了，自己写个程序插入吧（id列是自增主键列，不需要我们手动插入）。

访问方法（access method）的概念
----------------------

想必各位都用过高德地图来查找到某个地方的路线吧（此处没有为高德地图打广告的意思，他们没给我钱，大家用百度地图也可以啊），如果我们搜西安钟楼到大雁塔之间的路线的话，地图软件会给出n种路线供我们选择，如果我们实在闲的没事儿干并且足够有钱的话，还可以用南辕北辙的方式绕地球一圈到达目的地。也就是说，不论采用哪一种方式，我们最终的目标就是到达大雁塔这个地方。回到`MySQL`中来，我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉`MySQL`我们要获取的数据符合哪些规则，至于`MySQL`背地里是怎么把查询结果搞出来的那是`MySQL`自己的事儿。对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分为下边两种：

*   使用全表扫描进行查询
    
    这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。
    
*   使用索引进行查询
    
    因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：
    
    *   针对主键或唯一二级索引的等值查询
        
    *   针对普通二级索引的等值查询
        
    *   针对索引列的范围查询
        
    *   直接扫描整个索引
        

设计`MySQL`的大叔把`MySQL`执行查询语句的方式称之为`访问方法`或者`访问类型`。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能差老鼻子远了，就像是从钟楼到大雁塔，你可以坐火箭去，也可以坐飞机去，当然也可以坐乌龟去。下边细细道来各种`访问方法`的具体内容。

const
-----

有的时候我们可以通过主键列来定位一条记录，比方说这个查询：

    SELECT * FROM single_table WHERE id = 1438;
    

`MySQL`会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：

![image_1ctendl4319v659s1dfoj6lssl16.png-36.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="600" height="491"></svg>)

原谅我把聚簇索引对应的复杂的`B+`树结构搞了一个极度精简版，为了突出重点，我们忽略掉了`页`的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，对于`single_table`表的聚簇索引来说，展示的就是`id`列。我们想突出的重点就是：`B+`树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的`B+`树叶子节点中的记录就是按照`id`列排序的。`B+`树本来就是一个矮矮的大胖子，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：

    SELECT * FROM single_table WHERE key2 = 3841;
    

这个查询的执行过程的示意图就是这样：

![image_1cthurrlpbhlotsjru1dsjrrl30.png-110.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="845" height="618"></svg>)

可以看到这个查询的执行分两步，第一步先从`idx_key2`对应的`B+`树索引中根据`key2`列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的`id`值到聚簇索引中获取到完整的用户记录。

设计`MySQL`的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：`const`，意思是常数级别的，代价是可以忽略不计的。不过这种`const`访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个`const`访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。

对于唯一二级索引来说，查询该列为`NULL`值的情况比较特殊，比如这样：

    SELECT * FROM single_table WHERE key2 IS NULL;
    

因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用`const`访问方法来执行（至于是什么访问方法我们下边马上说）。

ref
---

有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：

    SELECT * FROM single_table WHERE key1 = 'abc';
    

对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的`id`值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以`MySQL`可能选择使用索引而不是全表扫描的方式来执行查询。设计`MySQL`的大叔就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：`ref`。我们看一下采用`ref`访问方法执行查询的图示：

![image_1ctf14vso11cdclsmc6ac8pru9h.png-109.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="762" height="606"></svg>)

从图示中可以看出，对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种`ref`访问方法比`const`差了那么一丢丢，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了），跟坐高铁差不多。不过需要注意下边两种情况：

*   二级索引列值为`NULL`的情况
    
    不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含`NULL`值的数量并不限制，所以我们采用`key IS NULL`这种形式的搜索条件最多只能使用`ref`的访问方法，而不是`const`的访问方法。
    
*   对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用`ref`的访问方法，比方说下边这几个查询：
    
        SELECT * FROM single_table WHERE key_part1 = 'god like';
        
        SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';
        
        SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';
        
    
    但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为`ref`了，比方说这样：
    
        SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
        
    

ref\_or\_null
-------------

有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为`NULL`的记录也找出来，就像下边这个查询：

    SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
    

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为`ref_or_null`，这个`ref_or_null`访问方法的执行过程如下：

![image_1ctf21uu8113m1ajm1rcitgf5eeco.png-122.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="757" height="597"></svg>)

可以看到，上边的查询相当于先分别从`idx_key1`索引对应的`B+`树中找出`key1 IS NULL`和`key1 = 'abc'`的两个连续的记录范围，然后根据这些二级索引记录中的`id`值再回表查找完整的用户记录。

range
-----

我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（`ref_or_null`比较奇特，还计算了值为`NULL`的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：

    SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
    

我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用`二级索引 + 回表`的方式执行，如果采用`二级索引 + 回表`的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中`key2`列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：

*   `key2`的值是`1438`
    
*   `key2`的值是`6328`
    
*   `key2`的值在`38`和`79`之间。
    

设计`MySQL`的大叔把这种利用索引进行范围匹配的访问方法称之为：`range`。

    小贴士：
    
    此处所说的使用索引进行范围匹配中的 `索引` 可以是聚簇索引，也可以是二级索引。
    

如果把这几个所谓的`key2`列的值需要满足的`范围`在数轴上体现出来的话，那应该是这个样子：

![image_1cth9mkf41li1dad1tnd6dm5139.png-9.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="654" height="150"></svg>)

也就是从数学的角度看，每一个所谓的范围都是数轴上的一个`区间`，3个范围也就对应着3个区间：

*   范围1：`key2 = 1438`
    
*   范围2：`key2 = 6328`
    
*   范围3：`key2 ∈ [38, 79]`，注意这里是闭区间。
    

我们可以把那种索引列等值匹配的情况称之为`单点区间`，上边所说的`范围1`和`范围2`都可以被称为单点区间，像`范围3`这种的我们可以称为连续范围区间。

index
-----

看下边这个查询：

    SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
    

由于`key_part2`并不是联合索引`idx_key_part`最左索引列，所以我们无法使用`ref`或者`range`访问方法来执行这个语句。但是这个查询符合下边这两个条件：

*   它的查询列表只有3个列：`key_part1`, `key_part2`, `key_part3`，而索引`idx_key_part`又包含这三个列。
    
*   搜索条件中只有`key_part2`列。这个列也包含在索引`idx_key_part`中。
    

也就是说我们可以直接通过遍历`idx_key_part`索引的叶子节点的记录来比较`key_part2 = 'abc'`这个条件是否成立，把匹配成功的二级索引记录的`key_part1`, `key_part2`, `key_part3`列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计`MySQL`的大叔就把这种采用遍历二级索引记录的执行方式称之为：`index`。

all
---

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于`InnoDB`表来说也就是直接扫描聚簇索引，设计`MySQL`的大叔把这种使用全表扫描执行查询的方式称之为：`all`。

注意事项
----

### 重温 二级索引 \+ 回表

一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：

    SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
    

查询优化器会识别到这个查询中的两个搜索条件：

*   `key1 = 'abc'`
    
*   `key2 > 1000`
    

优化器一般会根据`single_table`表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询（关于如何比较的细节我们后边的章节中会唠叨）。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的`WHERE`条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是`ref`的访问方法一般比`range`好，但这也不总是一定的，也可能采用`ref`访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用`idx_key1`索引进行查询，那么整个查询过程可以分为两个步骤：

*   步骤1：使用二级索引定位记录的阶段，也就是根据条件`key1 = 'abc'`从`idx_key1`索引代表的`B+`树中找到对应的二级索引记录。
    
*   步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行`回表`操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件`key2 > 1000`到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。
    

这里需要特别提醒大家的一点是，因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用`idx_key1`索引进行查询时只会用到与`key1`列有关的搜索条件，其余条件，比如`key2 > 1000`这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。

> 小贴士： 需要注意的是，我们说一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的，我们后边会详细唠叨的。

### 明确range访问方法使用的范围区间

其实对于`B+`树索引来说，只要索引列和常数使用`=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`（不等于也可以写成`<>`）或者`LIKE`操作符连接起来，就可以产生一个所谓的`区间`。

> 小贴士： LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引，具体原因我们在前边的章节中唠叨过了，这里就不赘述了。 IN操作符的效果和若干个等值匹配操作符`=`之间用\`OR\`连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的： SELECT * FROM single\_table WHERE key2 IN (1438, 6328); SELECT * FROM single\_table WHERE key2 = 1438 OR key2 = 6328;

不过在日常的工作中，一个查询的`WHERE`子句可能有很多个小的搜索条件，这些搜索条件需要使用`AND`或者`OR`操作符连接起来，虽然大家都知道这两个操作符的作用，但我还是要再说一遍：

*   `cond1 AND cond2` ：只有当`cond1`和`cond2`都为`TRUE`时整个表达式才为`TRUE`。
    
*   `cond1 OR cond2`：只要`cond1`或者`cond2`中有一个为`TRUE`整个表达式就为`TRUE`。
    

当我们想使用`range`访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由`AND`或`OR`组成的复杂搜索条件中提取出正确的范围区间。

#### 所有搜索条件都可以使用某个索引的情况

有时候每个搜索条件都可以使用到某个索引，比如下边这个查询语句：

    SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200;
    

这个查询中的搜索条件都可以使用到`key2`，也就是说每个搜索条件都对应着一个`idx_key2`的范围区间。这两个小的搜索条件使用`AND`连接起来，也就是要取两个范围区间的交集，在我们使用`range`访问方法执行查询时，使用的`idx_key2`索引的范围区间的确定过程就如下图所示：

![image_1ctia5p09rqss4413qq16gdbbj3q.png-44kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="937" height="306"></svg>)

`key2 > 100`和`key2 > 200`交集当然就是`key2 > 200`了，也就是说上边这个查询使用`idx_key2`的范围区间就是`(200, +∞)`。这东西小学都学过吧，再不济初中肯定都学过。我们再看一下使用`OR`将多个搜索条件连接在一起的情况：

    SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;
    

`OR`意味着需要取各个范围区间的并集，所以上边这个查询在我们使用`range`访问方法执行查询时，使用的`idx_key2`索引的范围区间的确定过程就如下图所示：

![image_1ctia94i617ihr5ncku4ed1gg247.png-49.1kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="912" height="313"></svg>)

也就是说上边这个查询使用`idx_key2`的范围区间就是`(100， +∞)`。

#### 有的搜索条件无法使用索引的情况

比如下边这个查询：

    SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
    

请注意，这个查询语句中能利用的索引只有`idx_key2`一个，而`idx_key2`这个二级索引的记录中又不包含`common_field`这个字段，所以在使用二级索引`idx_key2`定位记录的阶段用不到`common_field = 'abc'`这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而`范围区间`是为了到索引中取记录中提出的概念，所以在确定`范围区间`的时候不需要考虑`common_field = 'abc'`这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为`TRUE`就好了。

> 小贴士： 之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤。

我们把上边的查询中用不到`idx_key2`的搜索条件替换后就是这样：

    SELECT * FROM single_table WHERE key2 > 100 AND TRUE;
    

化简之后就是这样：

    SELECT * FROM single_table WHERE key2 > 100;
    

也就是说最上边那个查询使用`idx_key2`的范围区间就是：`(100, +∞)`。

再来看一下使用`OR`的情况：

    SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';
    

同理，我们把使用不到`idx_key2`索引的搜索条件替换为`TRUE`：

    SELECT * FROM single_table WHERE key2 > 100 OR TRUE;
    

接着化简：

    SELECT * FROM single_table WHERE TRUE;
    

额，这也就说说明如果我们强制使用`idx_key2`执行查询的话，对应的范围区间就是`(-∞, +∞)`，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用`OR`连接起来后是无法使用该索引的。

#### 复杂搜索条件下找出范围匹配的区间

有的查询的搜索条件可能特别复杂，光是找出范围匹配的各个区间就挺烦的，比方说下边这个：

    SELECT * FROM single_table WHERE 
            (key1 > 'xyz' AND key2 = 748 ) OR
            (key1 < 'abc' AND key1 > 'lmn') OR
            (key1 LIKE '%suf' AND key1 > 'zzz' AND (key2 < 8000 OR common_field = 'abc')) ;
    

我滴个神，这个搜索条件真是绝了，不过大家不要被复杂的表象迷住了双眼，按着下边这个套路分析一下：

*   首先查看`WHERE`子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。
    
    这个查询的搜索条件涉及到了`key1`、`key2`、`common_field`这3个列，然后`key1`列有普通的二级索引`idx_key1`，`key2`列有唯一二级索引`idx_key2`。
    
*   对于那些可能用到的索引，分析它们的范围区间。
    
    *   假设我们使用`idx_key1`执行查询
        
        *   我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为`TRUE`就好了。上边的查询中除了有关`key2`和`common_field`列不能使用到`idx_key1`索引外，`key1 LIKE '%suf'`也使用不到索引，所以把这些搜索条件替换为`TRUE`之后的样子就是这样：
            
                (key1 > 'xyz' AND TRUE ) OR
                (key1 < 'abc' AND key1 > 'lmn') OR
                (TRUE AND key1 > 'zzz' AND (TRUE OR TRUE))
                
            
            化简一下上边的搜索条件就是下边这样：
            
                (key1 > 'xyz') OR
                (key1 < 'abc' AND key1 > 'lmn') OR
                (key1 > 'zzz')
                
            
        *   替换掉永远为`TRUE`或`FALSE`的条件
            
            因为符合`key1 < 'abc' AND key1 > 'lmn'`永远为`FALSE`，所以上边的搜索条件可以被写成这样：
            
                (key1 > 'xyz') OR (key1 > 'zzz')
                
            
        *   继续化简区间
            
            `key1 > 'xyz'`和`key1 > 'zzz'`之间使用`OR`操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：`key1 > xyz`。也就是说：上边那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足`key1 > xyz`的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。
            
    *   假设我们使用`idx_key2`执行查询
        
        *   我们需要把那些用不到该索引的搜索条件暂时使用`TRUE`条件替换掉，其中有关`key1`和`common_field`的搜索条件都需要被替换掉，替换结果就是：
            
                (TRUE AND key2 = 748 ) OR
                (TRUE AND TRUE) OR
                (TRUE AND TRUE AND (key2 < 8000 OR TRUE))
                
            
            哎呀呀，`key2 < 8000 OR TRUE`的结果肯定是`TRUE`呀，也就是说化简之后的搜索条件成这样了：
            
                key2 = 748 OR TRUE
                
            
            这个化简之后的结果就更简单了：
            
                TRUE
                
            
            这个结果也就意味着如果我们要使用`idx_key2`索引执行查询语句的话，需要扫描`idx_key2`二级索引的所有记录，然后再回表，这不是得不偿失么，所以这种情况下不会使用`idx_key2`索引的。
            

### 索引合并

我们前边说过`MySQL`在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计`MySQL`的大叔把这种使用到多个索引来完成一次查询的执行方法称之为：`index merge`，具体的索引合并算法有下边三种。

#### Intersection合并

`Intersection`翻译过来的意思是`交集`。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：

    SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
    

假设这个查询使用`Intersection`合并的方式执行的话，那这个过程就是这样的：

*   从`idx_key1`二级索引对应的`B+`树中取出`key1 = 'a'`的相关记录。
    
*   从`idx_key3`二级索引对应的`B+`树中取出`key3 = 'b'`的相关记录。
    
*   二级索引的记录都是由`索引列 + 主键`构成的，所以我们可以计算出这两个结果集中`id`值的交集。
    
*   按照上一步生成的`id`值列表进行回表操作，也就是从聚簇索引中把指定`id`值的完整用户记录取出来，返回给用户。
    

这里有同学会思考：为啥不直接使用`idx_key1`或者`idx_key3`只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。

只读取一个二级索引的成本：

*   按照某个搜索条件读取一个二级索引
    
*   根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件
    

读取多个二级索引之后取交集成本：

*   按照不同的搜索条件分别读取不同的二级索引
    
*   将从多个二级索引得到的主键值取交集，然后进行回表操作
    

虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是`顺序I/O`，而回表操作是`随机I/O`，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为`回表`而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。

`MySQL`在某些特定的情况下才可能会使用到`Intersection`索引合并：

*   情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。
    
    比方说下边这个查询可能用到`idx_key1`和`idx_key_part`这两个二级索引进行`Intersection`索引合并的操作：
    
        SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';
        
    
    而下边这两个查询就不能进行`Intersection`索引合并：
    
        SELECT * FROM single_table WHERE key1 > 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';
        
        SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a';
        
    
    第一个查询是因为对`key1`进行了范围匹配，第二个查询是因为联合索引`idx_key_part`中的`key_part2`列并没有出现在搜索条件中，所以这两个查询不能进行`Intersection`索引合并。
    
*   情况二：主键列可以是范围匹配
    
    比方说下边这个查询可能用到主键和`idx_key1`进行`Intersection`索引合并的操作：
    
        SELECT * FROM single_table WHERE id > 100 AND key1 = 'a';
        
    

为啥呢？凭啥呀？突然冒出这么两个规定让大家一脸懵逼，下边我们慢慢品一品这里头的玄机。这话还得从`InnoDB`的索引结构说起，你要是记不清麻烦再回头看看。对于`InnoDB`的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由`索引列 + 主键`构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照`主键`的值进行排序的。所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用`Intersection`索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。

so？还是没看懂根据二级索引查询出的结果集是按照主键值排序的对使用`Intersection`索引合并有啥好处？小伙子，别忘了`Intersection`索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很easy啦。假设某个查询使用`Intersection`索引合并的方式从`idx_key1`和`idx_key2`这两个二级索引中获取到的主键值分别是：

*   从`idx_key1`中获取到已经排好序的主键值：1、3、5
    
*   从`idx_key2`中获取到已经排好序的主键值：2、3、4
    

那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了，如果还是觉得不太明白那继续往下看：

*   先取出这两个结果集中较小的主键值做比较，因为`1 < 2`，所以把`idx_key1`的结果集的主键值`1`丢弃，取出后边的`3`来比较。
    
*   因为`3 > 2`，所以把`idx_key2`的结果集的主键值`2`丢弃，取出后边的`3`来比较。
    
*   因为`3 = 3`，所以把`3`加入到最后的交集结果中，继续两个结果集后边的主键值来比较。
    
*   后边的主键值也不相等，所以最后的交集结果中只包含主键值`3`。
    

别看我们写的啰嗦，这个过程其实可快了，时间复杂度是`O(n)`，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。

> 小贴士： 按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，以后大家在某些地方见到这个名词儿就眼熟了。

另外，不仅是多个二级索引之间可以采用`Intersection`索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的`情况二`：在搜索条件中有主键的范围匹配的情况下也可以使用`Intersection`索引合并索引合并。为啥主键这就可以范围匹配了？还是得回到应用场景里，比如看下边这个查询：

    SELECT * FROM single_table WHERE key1 = 'a' AND id > 100;
    

假设这个查询可以采用`Intersection`索引合并，我们理所当然的以为这个查询会分别按照`id > 100`这个条件从聚簇索引中获取一些记录，在通过`key1 = 'a'`这个条件从`idx_key1`二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。别忘了二级索引的记录中都带有主键值的，所以可以在从`idx_key1`中获取到的主键值上直接运用条件`id > 100`过滤就行了，这样多简单。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。

当然，上边说的`情况一`和`情况二`只是发生`Intersection`索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生`Intersection`索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过`Intersection`索引合并后需要回表的记录数大大减少时才会使用`Intersection`索引合并。

#### Union合并

我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是`OR`关系。有时候`OR`关系的不同搜索条件会使用到不同的索引，比方说这样：

    SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
    

`Intersection`是交集的意思，这适用于使用不同索引的搜索条件之间使用`AND`连接起来的情况；`Union`是并集的意思，适用于使用不同索引的搜索条件之间使用`OR`连接起来的情况。与`Intersection`索引合并类似，`MySQL`在某些特定的情况下才可能会使用到`Union`索引合并：

*   情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。
    
    比方说下边这个查询可能用到`idx_key1`和`idx_key_part`这两个二级索引进行`Union`索引合并的操作：
    
        SELECT * FROM single_table WHERE key1 = 'a' OR ( key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');
        
    
    而下边这两个查询就不能进行`Union`索引合并：
    
        SELECT * FROM single_table WHERE key1 > 'a' OR (key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');
        
        SELECT * FROM single_table WHERE key1 = 'a' OR key_part1 = 'a';
        
    
    第一个查询是因为对`key1`进行了范围匹配，第二个查询是因为联合索引`idx_key_part`中的`key_part2`列并没有出现在搜索条件中，所以这两个查询不能进行`Union`索引合并。
    
*   情况二：主键列可以是范围匹配
    
*   情况三：使用`Intersection`索引合并的搜索条件
    
    这种情况其实也挺好理解，就是搜索条件的某些部分使用`Intersection`索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：
    
        SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');
        
    
    优化器可能采用这样的方式来执行这个查询：
    
    *   先按照搜索条件`key1 = 'a' AND key3 = 'b'`从索引`idx_key1`和`idx_key3`中使用`Intersection`索引合并的方式得到一个主键集合。
        
    *   再按照搜索条件`key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'`从联合索引`idx_key_part`中得到另一个主键集合。
        
    *   采用`Union`索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。
        

当然，查询条件符合了这些情况也不一定就会采用`Union`索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过`Union`索引合并后进行访问的代价比全表扫描更小时才会使用`Union`索引合并。

#### Sort-Union合并

`Union`索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到`Union`索引合并：

    SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
    

这是因为根据`key1 < 'a'`从`idx_key1`索引中获取的二级索引记录的主键值不是排好序的，根据`key3 > 'z'`从`idx_key3`索引中获取的二级索引记录的主键值也不是排好序的，但是`key1 < 'a'`和`key3 > 'z'`这两个条件又特别让我们动心，所以我们可以这样：

*   先根据`key1 < 'a'`条件从`idx_key1`二级索引中获取记录，并按照记录的主键值进行排序
    
*   再根据`key3 > 'z'`条件从`idx_key3`二级索引中获取记录，并按照记录的主键值进行排序
    
*   因为上述的两个二级索引主键值都是排好序的，剩下的操作和`Union`索引合并方式就一样了。
    

我们把上述这种先按照二级索引记录的主键值进行排序，之后按照`Union`索引合并方式执行的方式称之为`Sort-Union`索引合并，很显然，这种`Sort-Union`索引合并比单纯的`Union`索引合并多了一步对二级索引记录的主键值排序的过程。

> 小贴士： 为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说， Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高 而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。

#### 索引合并注意事项

#### 联合索引替代Intersection索引合并

    SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
    

这个查询之所以可能使用`Intersection`索引合并的方式执行，还不是因为`idx_key1`和`idx_key3`是两个单独的`B+`树索引，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了，何必用啥索引合并呢，就像这样：

    ALTER TABLE single_table drop index idx_key1, idx_key3, add index idx_key1_key3(key1, key3);
    

这样我们把没用的`idx_key1`、`idx_key3`都干掉，再添加一个联合索引`idx_key1_key3`，使用这个联合索引进行查询简直是又快又好，既不用多读一棵`B+`树，也不用合并结果，何乐而不为？

> 小贴士： 不过小心有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。页号。
    
*   `Root of SYS_FIELDS clust index`：本字段代表`SYS_FIELDS`表聚簇索引的根页面的页号。
    
*   `Unused`：这4个字节没用，跳过。
    

以上就是页号为`7`的页面的全部内容，初次看可能会懵逼（因为有点儿绕），大家多瞅几次。

##### information_schema系统数据库

需要注意一点的是，用户是不能直接访问`InnoDB`的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过设计InnoDB的大叔考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库`information_schema`中提供了一些以`innodb_sys`开头的表：

    mysql> USE information_schema;
    Database changed
    
    mysql> SHOW TABLES LIKE 'innodb_sys%';
    +--------------------------------------------+
    | Tables_in_information_schema (innodb_sys%) |
    +--------------------------------------------+
    | INNODB_SYS_DATAFILES                       |
    | INNODB_SYS_VIRTUAL                         |
    | INNODB_SYS_INDEXES                         |
    | INNODB_SYS_TABLES                          |
    | INNODB_SYS_FIELDS                          |
    | INNODB_SYS_TABLESPACES                     |
    | INNODB_SYS_FOREIGN_COLS                    |
    | INNODB_SYS_COLUMNS                         |
    | INNODB_SYS_FOREIGN                         |
    | INNODB_SYS_TABLESTATS                      |
    +--------------------------------------------+
    10 rows in set (0.00 sec)
    

在`information_schema`数据库中的这些以`INNODB_SYS`开头的表并不是真正的内部系统表（内部系统表就是我们上边唠叨的以`SYS`开头的那些表），而是在存储引擎启动时读取这些以`SYS`开头的系统表，然后填充到这些以`INNODB_SYS`开头的表中。以`INNODB_SYS`开头的表和以`SYS`开头的表中的字段并不完全一样，但供大家参考已经足矣。这些表太多了，我就不唠叨了，大家自个儿动手试着查一查这些表中的数据吧哈～

### 总结图

小册微信交流群2群中一个昵称为`think`同学非常有心的为表空间画了一个全局图，希望能对各位有帮助（这种学习态度实在让我感动😹）：

![image_1d9ppsbelendcbb13hghhn18pe9.png-3564.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="729"></svg>)