字符集和比较规则
========

标签： MySQL是怎样运行的

* * *

字符集和比较规则简介
----------

### 字符集简介

我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：

1.  你要把哪些字符映射成二进制数据？
    
    也就是界定清楚字符范围。
    
2.  怎么映射？
    
    将一个字符映射成一个二进制数据的过程也叫做`编码`，将一个二进制数据映射到一个字符的过程叫做`解码`。
    

人们抽象出一个`字符集`的概念来描述某个字符范围的编码规则。比方说我们来自定义一个名称为`xiaohaizi`的字符集，它包含的字符范围和编码规则如下：

*   包含字符`'a'`、`'b'`、`'A'`、`'B'`。
    
*   编码规则如下：
    
    采用1个字节编码一个字符的形式，字符和字节的映射关系如下：
    
        'a' -> 00000001 (十六进制：0x01)
        'b' -> 00000010 (十六进制：0x02)
        'A' -> 00000011 (十六进制：0x03)
        'B' -> 00000100 (十六进制：0x04)
        
    

有了`xiaohaizi`字符集，我们就可以用二进制形式表示一些字符串了，下边是一些字符串用`xiaohaizi`字符集编码后的二进制表示：

    'bA' -> 0000001000000011  (十六进制：0x0203)
    'baB' -> 000000100000000100000100  (十六进制：0x020104)
    'cd' -> 无法表示，字符集xiaohaizi不包含字符'c'和'd'
    

### 比较规则简介

在我们确定了`xiaohaizi`字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢？最容易想到的就是直接比较这两个字符对应的二进制编码的大小，比方说字符`'a'`的编码为`0x01`，字符`'b'`的编码为`0x02`，所以`'a'`小于`'b'`，这种简单的比较规则也可以被称为二进制比较规则，英文名为`binary collation`。

二进制比较规则是简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说`'a'`和`'A'`是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了，这时候我们可以这样指定比较规则：

1.  将两个大小写不同的字符全都转为大写或者小写。
2.  再比较这两个字符对应的二进制数据。

这是一种稍微复杂一点点的比较规则，但是实际生活中的字符不止英文字符一种，比如我们的汉字有几万之多，对于某一种字符集来说，比较两个字符大小的规则可以制定出很多种，也就是说同一种字符集可以有多种比较规则，我们稍后就要介绍各种现实生活中用的字符集以及它们的一些比较规则。

### 一些重要的字符集

不幸的是，这个世界太大了，不同的人制定出了好多种`字符集`，它们表示的字符范围和用到的编码规则可能都不一样。我们看一下一些常用字符集的情况：

*   `ASCII`字符集
    
    共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：
    
        'L' ->  01001100（十六进制：0x4C，十进制：76）
        'M' ->  01001101（十六进制：0x4D，十进制：77）
        
    
*   `ISO 8859-1`字符集
    
    共收录256个字符，是在`ASCII`字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名`latin1`。
    
*   `GB2312`字符集
    
    收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容`ASCII`字符集，所以在编码方式上显得有些奇怪：
    
    *   如果该字符在`ASCII`字符集中，则采用1字节编码。
    *   否则采用2字节编码。
    
    这种表示一个字符需要的字节数可能不同的编码方式称为`变长编码方式`。比方说字符串`'爱u'`，其中`'爱'`需要用2个字节进行编码，编码后的十六进制表示为`0xCED2`，`'u'`需要用1个字节进行编码，编码后的十六进制表示为`0x75`，所以拼合起来就是`0xCED275`。
    
    > 小贴士： 我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢？别忘了\`ASCII\`字符集只收录128个字符，使用0～127就可以表示全部字符，所以如果某个字节是在0～127之内的，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。
    
*   `GBK`字符集
    
    `GBK`字符集只是在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容`GB2312`。
    
*   `utf8`字符集
    
    收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容`ASCII`字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比方说这样：
    
        'L' ->  01001100（十六进制：0x4C）
        '啊' ->  111001011001010110001010（十六进制：0xE5958A）
        
    
    > 小贴士： 其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查哈～ MySQL中并不区分字符集和编码方案的概念，所以后边唠叨的时候把utf8、utf16、utf32都当作一种字符集对待。
    

对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字`'我'`来说，`ASCII`字符集中根本没有收录这个字符，`utf8`和`gb2312`字符集对汉字`我`的编码方式如下：

    utf8编码：111001101000100010010001 (3个字节，十六进制表示是：0xE68891)
    gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2)
    

MySQL中支持的字符集和排序规则
-----------------

### MySQL中的utf8和utf8mb4

我们上边说`utf8`字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在`MySQL`中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计`MySQL`的大叔偷偷的定义了两个概念：

*   `utf8mb3`：阉割过的`utf8`字符集，只使用1～3个字节表示字符。
    
*   `utf8mb4`：正宗的`utf8`字符集，使用1～4个字节表示字符。
    

有一点需要大家十分的注意，在`MySQL`中`utf8`是`utf8mb3`的别名，所以之后在`MySQL`中提到`utf8`就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用`utf8mb4`。

### 字符集的查看

`MySQL`支持好多好多种字符集，查看当前`MySQL`中支持的字符集可以用下边这个语句：

    SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
    

其中`CHARACTER SET`和`CHARSET`是同义词，用任意一个都可以。我们查询一下（支持的字符集太多了，我们省略了一些）：

    mysql> SHOW CHARSET;
    +----------+---------------------------------+---------------------+--------+
    | Charset  | Description                     | Default collation   | Maxlen |
    +----------+---------------------------------+---------------------+--------+
    | big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |
    ...
    | latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
    | latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |
    ...
    | ascii    | US ASCII                        | ascii_general_ci    |      1 |
    ...
    | gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
    ...
    | gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
    | latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |
    ...
    | utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
    | ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |
    ...
    | latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |
    | utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
    | utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
    | utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |
    ...
    | utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
    | binary   | Binary pseudo charset           | binary              |      1 |
    ...
    | gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |
    +----------+---------------------------------+---------------------+--------+
    41 rows in set (0.01 sec)
    

可以看到，我使用的这个`MySQL`版本一共支持`41`种字符集，其中的`Default collation`列表示这种字符集中一种默认的`比较规则`。大家注意返回结果中的最后一列`Maxlen`，它代表该种字符集表示一个字符最多需要几个字节。为了让大家的印象更深刻，我把几个常用到的字符集的`Maxlen`列摘抄下来，大家务必记住：

字符集名称

Maxlen

`ascii`

`1`

`latin1`

`1`

`gb2312`

`2`

`gbk`

`2`

`utf8`

`3`

`utf8mb4`

`4`

### 比较规则的查看

查看`MySQL`中支持的比较规则的命令如下：

    SHOW COLLATION [LIKE 匹配的模式];
    

我们前边说过一种字符集可能对应着若干种比较规则，`MySQL`支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下`utf8`字符集下的比较规则：

    mysql> SHOW COLLATION LIKE 'utf8\_%';
    +--------------------------+---------+-----+---------+----------+---------+
    | Collation                | Charset | Id  | Default | Compiled | Sortlen |
    +--------------------------+---------+-----+---------+----------+---------+
    | utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |
    | utf8_bin                 | utf8    |  83 |         | Yes      |       1 |
    | utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |
    | utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |
    | utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |
    | utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |
    | utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |
    | utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |
    | utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |
    | utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |
    | utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |
    | utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |
    | utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |
    | utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |
    | utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |
    | utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |
    | utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |
    | utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |
    | utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |
    | utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |
    | utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |
    | utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |
    | utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |
    | utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |
    | utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |
    | utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |
    | utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |
    +--------------------------+---------+-----+---------+----------+---------+
    27 rows in set (0.00 sec)
    

这些比较规则的命名还挺有规律的，具体规律如下：

*   比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以`utf8`开头的。
    
*   后边紧跟着该比较规则主要作用于哪种语言，比如`utf8_polish_ci`表示以波兰语的规则比较，`utf8_spanish_ci`是以西班牙语的规则比较，`utf8_general_ci`是一种通用的比较规则。
    
*   名称后缀意味着该比较规则是否区分语言中的重音、大小写啥的，具体可以用的值如下：
    
    后缀
    
    英文释义
    
    描述
    
    `_ai`
    
    `accent insensitive`
    
    不区分重音
    
    `_as`
    
    `accent sensitive`
    
    区分重音
    
    `_ci`
    
    `case insensitive`
    
    不区分大小写
    
    `_cs`
    
    `case sensitive`
    
    区分大小写
    
    `_bin`
    
    `binary`
    
    以二进制方式比较
    
    比如`utf8_general_ci`这个比较规则是以`ci`结尾的，说明不区分大小写。
    

每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则，`SHOW COLLATION`的返回结果中的`Default`列的值为`YES`的就是该字符集的默认比较规则，比方说`utf8`字符集默认的比较规则就是`utf8_general_ci`。

字符集和比较规则的应用
-----------

### 各级别的字符集和比较规则

`MySQL`有4个级别的字符集和比较规则，分别是：

*   服务器级别
*   数据库级别
*   表级别
*   列级别

我们接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。

#### 服务器级别

`MySQL`提供了两个系统变量来表示服务器级别的字符集和比较规则：

系统变量

描述

`character_set_server`

服务器级别的字符集

`collation_server`

服务器级别的比较规则

我们看一下这两个系统变量的值：

    mysql> SHOW VARIABLES LIKE 'character_set_server';
    +----------------------+-------+
    | Variable_name        | Value |
    +----------------------+-------+
    | character_set_server | utf8  |
    +----------------------+-------+
    1 row in set (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'collation_server';
    +------------------+-----------------+
    | Variable_name    | Value           |
    +------------------+-----------------+
    | collation_server | utf8_general_ci |
    +------------------+-----------------+
    1 row in set (0.00 sec)
    
    

可以看到在我的计算机中服务器级别默认的字符集是`utf8`，默认的比较规则是`utf8_general_ci`。

我们可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用`SET`语句修改这两个变量的值。比如我们可以在配置文件中这样写：

    [server]
    character_set_server=gbk
    collation_server=gbk_chinese_ci
    

当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。

#### 数据库级别

我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：

    CREATE DATABASE 数据库名
        [[DEFAULT] CHARACTER SET 字符集名称]
        [[DEFAULT] COLLATE 比较规则名称];
    
    ALTER DATABASE 数据库名
        [[DEFAULT] CHARACTER SET 字符集名称]
        [[DEFAULT] COLLATE 比较规则名称];
    

其中的`DEFAULT`可以省略，并不影响语句的语义。比方说我们新创建一个名叫`charset_demo_db`的数据库，在创建的时候指定它使用的字符集为`gb2312`，比较规则为`gb2312_chinese_ci`：

    mysql> CREATE DATABASE charset_demo_db
        -> CHARACTER SET gb2312
        -> COLLATE gb2312_chinese_ci;
    Query OK, 1 row affected (0.01 sec)
    

如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值（前提是使用`USE`语句选择当前默认数据库，如果没有默认数据库，则变量与相应的服务器级系统变量具有相同的值）：

系统变量

描述

`character_set_database`

当前数据库的字符集

`collation_database`

当前数据库的比较规则

我们来查看一下刚刚创建的`charset_demo_db`数据库的字符集和比较规则：

    mysql> USE charset_demo_db;
    Database changed
    
    mysql> SHOW VARIABLES LIKE 'character_set_database';
    +------------------------+--------+
    | Variable_name          | Value  |
    +------------------------+--------+
    | character_set_database | gb2312 |
    +------------------------+--------+
    1 row in set (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'collation_database';
    +--------------------+-------------------+
    | Variable_name      | Value             |
    +--------------------+-------------------+
    | collation_database | gb2312_chinese_ci |
    +--------------------+-------------------+
    1 row in set (0.00 sec)
    
    mysql>
    

可以看到这个`charset_demo_db`数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： _**character\_set\_database**_ 和 _**collation_database**_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。

数据库的创建语句中也可以不指定字符集和比较规则，比如这样：

    CREATE DATABASE 数据库名;
    

这样的话将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则。

#### 表级别

我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：

    CREATE TABLE 表名 (列的信息)
        [[DEFAULT] CHARACTER SET 字符集名称]
        [COLLATE 比较规则名称]]
    
    ALTER TABLE 表名
        [[DEFAULT] CHARACTER SET 字符集名称]
        [COLLATE 比较规则名称]
    

比方说我们在刚刚创建的`charset_demo_db`数据库中创建一个名为`t`的表，并指定这个表的字符集和比较规则：

    mysql> CREATE TABLE t(
        ->     col VARCHAR(10)
        -> ) CHARACTER SET utf8 COLLATE utf8_general_ci;
    Query OK, 0 rows affected (0.03 sec)
    

如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。假设我们的创建表`t`的语句是这么写的：

    CREATE TABLE t(
        col VARCHAR(10)
    );
    

因为表`t`的建表语句中并没有明确指定字符集和比较规则，则表`t`的字符集和比较规则将继承所在数据库`charset_demo_db`的字符集和比较规则，也就是`gb2312`和`gb2312_chinese_ci`。

#### 列级别

需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：

    CREATE TABLE 表名(
        列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
        其他列...
    );
    
    ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
    

比如我们修改一下表`t`中列`col`的字符集和比较规则可以这么写：

    mysql> ALTER TABLE t MODIFY col VARCHAR(10) CHARACTER SET gbk COLLATE gbk_chinese_ci;
    Query OK, 0 rows affected (0.04 sec)
    Records: 0  Duplicates: 0  Warnings: 0
    
    mysql>
    

对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。比方说表`t`的字符集是`utf8`，比较规则是`utf8_general_ci`，修改列`col`的语句是这么写的：

    ALTER TABLE t MODIFY col VARCHAR(10);
    

那列`col`的字符集和编码将使用表`t`的字符集和比较规则，也就是`utf8`和`utf8_general_ci`。

> 小贴士： 在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。

#### 仅修改字符集或仅修改比较规则

由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：

*   只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。
*   只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。

不论哪个级别的字符集和比较规则，这两条规则都适用，我们以服务器级别的字符集和比较规则为例来看一下详细过程：

*   只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。
    
        mysql> SET character_set_server = gb2312;
        Query OK, 0 rows affected (0.00 sec)
        
        mysql> SHOW VARIABLES LIKE 'character_set_server';
        +----------------------+--------+
        | Variable_name        | Value  |
        +----------------------+--------+
        | character_set_server | gb2312 |
        +----------------------+--------+
        1 row in set (0.00 sec)
        
        mysql>  SHOW VARIABLES LIKE 'collation_server';
        +------------------+-------------------+
        | Variable_name    | Value             |
        +------------------+-------------------+
        | collation_server | gb2312_chinese_ci |
        +------------------+-------------------+
        1 row in set (0.00 sec)
        
    
    我们只修改了`character_set_server`的值为`gb2312`，`collation_server`的值自动变为了`gb2312_chinese_ci`。
    
*   只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。
    
        mysql> SET collation_server = utf8_general_ci;
        Query OK, 0 rows affected (0.00 sec)
        
        mysql> SHOW VARIABLES LIKE 'character_set_server';
        +----------------------+-------+
        | Variable_name        | Value |
        +----------------------+-------+
        | character_set_server | utf8  |
        +----------------------+-------+
        1 row in set (0.00 sec)
        
        mysql> SHOW VARIABLES LIKE 'collation_server';
        +------------------+-----------------+
        | Variable_name    | Value           |
        +------------------+-----------------+
        | collation_server | utf8_general_ci |
        +------------------+-----------------+
        1 row in set (0.00 sec)
        
        mysql>
        
    
    我们只修改了`collation_server`的值为`utf8_general_ci`，`character_set_server`的值自动变为了`utf8`。
    

#### 各级别字符集和比较规则小结

我们介绍的这4个级别字符集和比较规则的联系如下：

*   如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则
*   如果创建或修改表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则
*   如果创建或修改数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则

知道了这些规则之后，对于给定的表，我们应该知道它的各个列的字符集和比较规则是什么，从而根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小了。比方说我们向表`t`中插入一条记录：

    mysql> INSERT INTO t(col) VALUES('我我');
    Query OK, 1 row affected (0.00 sec)
    
    mysql> SELECT * FROM t;
    +--------+
    | s      |
    +--------+
    | 我我   |
    +--------+
    1 row in set (0.00 sec)
    

首先列`col`使用的字符集是`gbk`，一个字符`'我'`在`gbk`中的编码为`0xCED2`，占用两个字节，两个字符的实际数据就占用4个字节。如果把该列的字符集修改为`utf8`的话，这两个字符就实际占用6个字节啦～

### 客户端和服务器通信中的字符集

#### 编码和解码使用的字符集不一致的后果

说到底，字符串在计算机上的体现就是一个字节串，如果你使用不同字符集去解码这个字节串，最后得到的结果可能让你挠头。

我们知道字符`'我'`在`utf8`字符集编码下的字节串长这样：`0xE68891`，如果一个程序把这个字节串发送到另一个程序里，另一个程序用不同的字符集去解码这个字节串，假设使用的是`gbk`字符集来解释这串字节，解码过程就是这样的：

1.  首先看第一个字节`0xE6`，它的值大于`0x7F`（十进制：127），说明是两字节编码，继续读一字节后是`0xE688`，然后从`gbk`编码表中查找字节为`0xE688`对应的字符，发现是字符`'鎴'`
    
2.  继续读一个字节`0x91`，它的值也大于`0x7F`，再往后读一个字节发现木有了，所以这是半个字符。
    
3.  所以`0xE68891`被`gbk`字符集解释成一个字符`'鎴'`和半个字符。
    

假设用`iso-8859-1`，也就是`latin1`字符集去解释这串字节，解码过程如下：

1.  先读第一个字节`0xE6`，它对应的`latin1`字符为`æ`。
    
2.  再读第二个字节`0x88`，它对应的`latin1`字符为`ˆ`。
    
3.  再读第三个字节`0x91`，它对应的`latin1`字符为`‘`。
    
4.  所以整串字节`0xE68891`被`latin1`字符集解释后的字符串就是`'æˆ‘'`
    

可见，如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。

#### 字符集转换的概念

如果接收`0xE68891`这个字节串的程序按照`utf8`字符集进行解码，然后又把它按照`gbk`字符集进行编码，最后编码后的字节串就是`0xCED2`，我们把这个过程称为`字符集的转换`，也就是字符串`'我'`从`utf8`字符集转换为`gbk`字符集。

#### MySQL中字符集的转换

我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到3个系统变量，我们先把它们写出来看一下：

系统变量

描述

`character_set_client`

服务器解码请求时使用的字符集

`character_set_connection`

服务器处理请求时会把请求字符串从`character_set_client`转为`character_set_connection`

`character_set_results`

服务器向客户端返回数据时使用的字符集

这几个系统变量在我的计算机上的默认值如下（不同操作系统的默认值可能不同）：

    mysql> SHOW VARIABLES LIKE 'character_set_client';
    +----------------------+-------+
    | Variable_name        | Value |
    +----------------------+-------+
    | character_set_client | utf8  |
    +----------------------+-------+
    1 row in set (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'character_set_connection';
    +--------------------------+-------+
    | Variable_name            | Value |
    +--------------------------+-------+
    | character_set_connection | utf8  |
    +--------------------------+-------+
    1 row in set (0.01 sec)
    
    mysql> SHOW VARIABLES LIKE 'character_set_results';
    +-----------------------+-------+
    | Variable_name         | Value |
    +-----------------------+-------+
    | character_set_results | utf8  |
    +-----------------------+-------+
    1 row in set (0.00 sec)
    

大家可以看到这几个系统变量的值都是`utf8`，为了体现出字符集在请求处理过程中的变化，我们这里特意修改一个系统变量的值：

    mysql> set character_set_connection = gbk;
    Query OK, 0 rows affected (0.00 sec)
    

所以现在系统变量`character_set_client`和`character_set_results`的值还是`utf8`，而`character_set_connection`的值为`gbk`。现在假设我们客户端发送的请求是下边这个字符串：

    SELECT * FROM t WHERE s = '我';
    

为了方便大家理解这个过程，我们只分析字符`'我'`在这个过程中字符集的转换。

现在看一下在请求从发送到结果返回过程中字符集的变化：

1.  客户端发送请求所使用的字符集
    
    一般情况下客户端所使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一样，如下：
    
    *   类`Unix`系统使用的是`utf8`
    *   `Windows`使用的是`gbk`
    
    例如我在使用的`macOS`操作系统时，客户端使用的就是`utf8`字符集。所以字符`'我'`在发送给服务器的请求中的字节形式就是：`0xE68891`
    
    > 小贴士： 如果你使用的是可视化工具，比如navicat之类的，这些工具可能会使用自定义的字符集来编码发送到服务器的字符串，而不采用操作系统默认的字符集（所以在学习的时候还是尽量用黑框框哈）。
    
2.  服务器接收到客户端发送来的请求其实是一串二进制的字节，它会认为这串字节采用的字符集是`character_set_client`，然后把这串字节转换为`character_set_connection`字符集编码的字符。
    
    由于我的计算机上`character_set_client`的值是`utf8`，首先会按照`utf8`字符集对字节串`0xE68891`进行解码，得到的字符串就是`'我'`，然后按照`character_set_connection`代表的字符集，也就是`gbk`进行编码，得到的结果就是字节串`0xCED2`。
    
3.  因为表`t`的列`col`采用的是`gbk`字符集，与`character_set_connection`一致，所以直接到列中找字节值为`0xCED2`的记录，最后找到了一条记录。
    
    > 小贴士： 如果某个列使用的字符集和character\_set\_connection代表的字符集不一致的话，还需要进行一次字符集转换。
    
4.  上一步骤找到的记录中的`col`列其实是一个字节串`0xCED2`，`col`列是采用`gbk`进行编码的，所以首先会将这个字节串使用`gbk`进行解码，得到字符串`'我'`，然后再把这个字符串使用`character_set_results`代表的字符集，也就是`utf8`进行编码，得到了新的字节串：`0xE68891`，然后发送给客户端。
    
5.  由于客户端是用的字符集是`utf8`，所以可以顺利的将`0xE68891`解释成字符`我`，从而显示到我们的显示器上，所以我们人类也读懂了返回的结果。
    

如果你读上边的文字有点晕，可以参照这个图来仔细分析一下这几个步骤：

![image_1d6dfk4orjaj1ra8536aijb99.png-112.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="974" height="469"></svg>)

从这个分析中我们可以得出这么几点需要注意的地方：

*   服务器认为客户端发送过来的请求是用`character_set_client`编码的。
    
    假设你的客户端采用的字符集和 _**character\_set\_client**_ 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是`utf8`字符集，如果把系统变量`character_set_client`的值设置为`ascii`的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。
    
*   服务器将把得到的结果集使用`character_set_results`编码后发送给客户端。
    
    假设你的客户端采用的字符集和 _**character\_set\_results**_ 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是`utf8`字符集，如果把系统变量`character_set_results`的值设置为`ascii`的话，可能会产生乱码。
    
*   `character_set_connection`只是服务器在将请求的字节串从`character_set_client`转换为`character_set_connection`时使用，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求中的字符，要不然会导致有的字符无法使用`character_set_connection`代表的字符集进行编码。比如你把`character_set_client`设置为`utf8`，把`character_set_connection`设置成`ascii`，那么此时你如果从客户端发送一个汉字到服务器，那么服务器无法使用`ascii`字符集来编码这个汉字，就会向用户发出一个警告。
    

知道了在`MySQL`中从发送请求到返回结果过程里发生的各种字符集转换，但是为啥要转来转去的呢？不晕么？

答：是的，很头晕，所以我们通常都把 _**character\_set\_client**_ 、_**character\_set\_connection**_、_**character\_set\_results**_ 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，`MySQL`提供了一条非常简便的语句：

    SET NAMES 字符集名;
    

这一条语句产生的效果和我们执行这3条的效果是一样的：

    SET character_set_client = 字符集名;
    SET character_set_connection = 字符集名;
    SET character_set_results = 字符集名;
    

比方说我的客户端使用的是`utf8`字符集，所以需要把这几个系统变量的值都设置为`utf8`：

    mysql> SET NAMES utf8;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'character_set_client';
    +----------------------+-------+
    | Variable_name        | Value |
    +----------------------+-------+
    | character_set_client | utf8  |
    +----------------------+-------+
    1 row in set (0.00 sec)
    
    mysql>  SHOW VARIABLES LIKE 'character_set_connection';
    +--------------------------+-------+
    | Variable_name            | Value |
    +--------------------------+-------+
    | character_set_connection | utf8  |
    +--------------------------+-------+
    1 row in set (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'character_set_results';
    +-----------------------+-------+
    | Variable_name         | Value |
    +-----------------------+-------+
    | character_set_results | utf8  |
    +-----------------------+-------+
    1 row in set (0.00 sec)
    
    mysql>
    

> 小贴士： 如果你使用的是Windows系统，那应该设置成gbk。

另外，如果你想在启动客户端的时候就把`character_set_client`、`character_set_connection`、`character_set_results`这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫`default-character-set`的启动选项，比如在配置文件里可以这么写：

    [client]
    default-character-set=utf8
    

它起到的效果和执行一遍`SET NAMES utf8`是一样一样的，都会将那三个系统变量的值设置成`utf8`。

### 比较规则的应用

结束了字符集的漫游，我们把视角再次聚焦到`比较规则`，`比较规则`的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中，所以有时候也称为`排序规则`。比方说表`t`的列`col`使用的字符集是`gbk`，使用的比较规则是`gbk_chinese_ci`，我们向里边插入几条记录：

    mysql> INSERT INTO t(col) VALUES('a'), ('b'), ('A'), ('B');
    Query OK, 4 rows affected (0.00 sec)
    Records: 4  Duplicates: 0  Warnings: 0
    
    mysql>
    

我们查询的时候按照`t`列排序一下：

    mysql> SELECT * FROM t ORDER BY col;
    +------+
    | col  |
    +------+
    | a    |
    | A    |
    | b    |
    | B    |
    | 我   |
    +------+
    5 rows in set (0.00 sec)
    

可以看到在默认的比较规则`gbk_chinese_ci`中是不区分大小写的，我们现在把列`col`的比较规则修改为`gbk_bin`：

    mysql> ALTER TABLE t MODIFY col VARCHAR(10) COLLATE gbk_bin;
    Query OK, 5 rows affected (0.02 sec)
    Records: 5  Duplicates: 0  Warnings: 0
    

由于`gbk_bin`是直接比较字符的编码，所以是区分大小写的，我们再看一下排序后的查询结果：

    mysql> SELECT * FROM t ORDER BY s;
    +------+
    | s    |
    +------+
    | A    |
    | B    |
    | a    |
    | b    |
    | 我   |
    +------+
    5 rows in set (0.00 sec)
    
    mysql>
    

所以如果以后大家在对字符串做比较或者对某个字符串列做排序操作时没有得到想象中的结果，需要思考一下是不是`比较规则`的问题～

    小贴士：
    
    列`col`中各个字符在使用gbk字符集编码后对应的数字如下：
    'A' -> 65 （十进制）
    'B' -> 66 （十进制）
    'a' -> 97 （十进制）
    'b' -> 98 （十进制）
    '我' -> 25105 （十进制）
    
    

总结
--

1.  `字符集`指的是某个字符范围的编码规则。
    
2.  `比较规则`是针对某个字符集中的字符比较大小的一种规则。
    
3.  在`MySQL`中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则InnoDB记录存储结构
============

标签： MySQL是怎样运行的

* * *

准备工作
----

到现在为止，`MySQL`对于我们来说还是一个黑盒，我们只负责使用客户端发送请求并等待服务器返回结果，表中的数据到底存到了哪里？以什么格式存放的？`MySQL`是以什么方式来访问的这些数据？这些问题我们统统不知道，对于未知领域的探索向来就是社会主义核心价值观中的一部分，作为新一代社会主义接班人，不把它们搞懂怎么支援祖国建设呢？

我们前边唠叨请求处理过程的时候提到过，`MySQL`服务器上负责对表中数据的读取和写入工作的部分是`存储引擎`，而服务器又支持不同类型的存储引擎，比如`InnoDB`、`MyISAM`、`Memory`啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如`Memory`都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于`InnoDB`是`MySQL`默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用`InnoDB`作为存储引擎的数据存储结构，了解了一个存储引擎的数据存储结构之后，其他的存储引擎都是依葫芦画瓢，等我们用到了再说哈～

InnoDB页简介
---------

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB`存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，`InnoDB`采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 _**16**_ KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

InnoDB行格式
---------

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。设计`InnoDB`存储引擎的大叔们到现在为止设计了4种不同类型的`行格式`，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

### 指定行格式的语法

我们可以在创建或修改表的语句中指定`行格式`：

    CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
        
    ALTER TABLE 表名 ROW_FORMAT=行格式名称
    

比如我们在`xiaohaizi`数据库里创建一个演示用的表`record_format_demo`，可以这样指定它的`行格式`：

    mysql> USE xiaohaizi;
    Database changed
    
    mysql> CREATE TABLE record_format_demo (
        ->     c1 VARCHAR(10),
        ->     c2 VARCHAR(10) NOT NULL,
        ->     c3 CHAR(10),
        ->     c4 VARCHAR(10)
        -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
    Query OK, 0 rows affected (0.03 sec)
    

可以看到我们刚刚创建的这个表的`行格式`就是`Compact`，另外，我们还显式指定了这个表的字符集为`ascii`，因为`ascii`字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：

    mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
    Query OK, 2 rows affected (0.02 sec)
    Records: 2  Duplicates: 0  Warnings: 0
    

现在表中的记录就是这个样子的：

    mysql> SELECT * FROM record_format_demo;
    +------+-----+------+------+
    | c1   | c2  | c3   | c4   |
    +------+-----+------+------+
    | aaaa | bbb | cc   | d    |
    | eeee | fff | NULL | NULL |
    +------+-----+------+------+
    2 rows in set (0.00 sec)
    
    mysql>
    

演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～

### COMPACT行格式

废话不多说，直接看图：

![image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="783" height="250"></svg>)

大家从图中可以看出来，一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分，下边我们详细看一下这两部分的组成。

#### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`，我们分别看一下。

##### 变长字段长度列表

我们知道`MySQL`支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，我们也可以把拥有这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1.  真正的数据内容
2.  占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！

我们拿`record_format_demo`表中的第一条记录来举个例子。因为`record_format_demo`表的`c1`、`c2`、`c4`列都是`VARCHAR(10)`类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为`record_format_demo`表中的各个列都使用的是`ascii`字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

列名

存储内容

内容长度（十进制表示）

内容长度（十六进制表示）

`c1`

`'aaaa'`

`4`

`0x04`

`c2`

`'bbb'`

`3`

`0x03`

`c4`

`'d'`

`1`

`0x01`

又因为这些长度值需要按照列的逆序存放，所以最后`变长字段长度列表`的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：

    01 03 04 
    

把这个字节串组成的`变长字段长度列表`填入上边的示意图中的效果就是：

![image_1c9gbruvo504dlg1qsf19nbeu878.png-37kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1004" height="192"></svg>)

由于第一行记录中`c1`、`c2`、`c4`列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，`InnoDB`有它的一套规则，我们首先声明一下`W`、`M`和`L`的意思：

1.  假设某个字符集中表示一个字符最多需要使用的字节数为`W`，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`字符集中的`W`就是`3`，`gbk`字符集中的`W`就是`2`，`ascii`字符集中的`W`就是`1`。
    
2.  对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是`M×W`。
    
3.  假设它实际存储的字符串占用的字节数是`L`。
    

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

*   如果`M×W <= 255`，那么使用1个字节来表示真正字符串占用的字节数。
    
    > 也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
    
*   如果`M×W > 255`，则分为两种情况：
    
    *   如果`L <= 127`，则用1个字节来表示真正字符串占用的字节数。
        
    *   如果`L > 127`，则用2个字节来表示真正字符串占用的字节数。
        
    
    > InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。 对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。
    

总结一下就是说：如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节。

另外需要注意的一点是，变长字段长度列表中只存储值为 _**非NULL**_ 的列内容占用的长度，值为 _**NULL**_ 的列的长度是不储存的 。也就是说对于第二条记录来说，因为`c4`列的值为`NULL`，所以第二条记录的`变长字段长度列表`只需要存储`c1`和`c2`列的长度即可。其中`c1`列存储的值为`'eeee'`，占用的字节数为`4`，`c2`列存储的值为`'fff'`，占用的字节数为`3`。数字`4`可以用1个字节表示，`3`也可以用1个字节表示，所以整个`变长字段长度列表`共需2个字节。填充完`变长字段长度列表`的两条记录的对比图如下：

![image_1c9grq2b2jok1062t8tov21lqjbj.png-42.6kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="742" height="239"></svg>)

> 小贴士： 并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

##### NULL值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1.  首先统计表中允许存储`NULL`的列有哪些。
    
    我们前边说过，主键列、被`NOT NULL`修饰的列都是不可以存储`NULL`值的，所以在统计的时候不会把这些列算进去。比方说表`record_format_demo`的3个列`c1`、`c3`、`c4`都是允许存储`NULL`值的，而`c2`列是被`NOT NULL`修饰，不允许存储`NULL`值。
    
2.  如果表中没有允许存储 _**NULL**_ 的列，则 _NULL值列表_ 也不存在了，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
    
    *   二进制位的值为`1`时，代表该列的值为`NULL`。
    *   二进制位的值为`0`时，代表该列的值不为`NULL`。
    
    因为表`record_format_demo`有3个值允许为`NULL`的列，所以这3个列和二进制位的对应关系就是这样：
    
    ![image_1c9g88mtt1tj51ua1qh51vjo12pg5k.png-10.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="247" height="229"></svg>)
    
    再一次强调，二进制位按照列的顺序逆序排列，所以第一个列`c1`和最后一个二进制位对应。
    
3.  `MySQL`规定`NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。
    
    表`record_format_demo`只有3个值允许为`NULL`的列，对应3个二进制位，不足一个字节，所以在字节的高位补`0`，效果就是这样：
    
    ![image_1c9g8g27b1bdlu7t187emsc46s61.png-19.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="374" height="301"></svg>)
    
    以此类推，如果一个表中有9个允许为`NULL`，那这个记录的`NULL`值列表部分就需要2个字节来表示了。
    

知道了规则之后，我们再返回头看表`record_format_demo`中的两条记录中的`NULL值列表`应该怎么储存。因为只有`c1`、`c3`、`c4`这3个列允许存储`NULL`值，所以所有记录的`NULL值列表`只需要一个字节。

*   对于第一条记录来说，`c1`、`c3`、`c4`这3个列的值都不为`NULL`，所以它们对应的二进制位都是`0`，画个图就是这样：
    
    ![image_1c9g8m05b19ge1c8v2bf163djre6e.png-21.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="346" height="308"></svg>)
    
    所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。
    
*   对于第二条记录来说，`c1`、`c3`、`c4`这3个列中`c3`和`c4`的值都为`NULL`，所以这3个列对应的二进制位的情况就是：
    
    ![image_1c9g8ps5c1snv1bhj3m48151sfl6r.png-20.6kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="332" height="316"></svg>)
    
    所以第二条记录的`NULL值列表`用十六进制表示就是：`0x06`。
    

所以这两条记录在填充了`NULL值列表`后的示意图就是这样：

![image_1c9grs9m4co8134u1t2rjhm1q6rc0.png-39kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="729" height="233"></svg>)

##### 记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1174" height="244"></svg>)

这些二进制位代表的详细信息如下表：

名称

大小（单位：bit）

描述

`预留位1`

`1`

没有使用

`预留位2`

`1`

没有使用

`delete_mask`

`1`

标记该记录是否被删除

`min_rec_mask`

`1`

B+树的每层非叶子节点中的最小记录都会添加该标记

`n_owned`

`4`

表示当前记录拥有的记录数

`heap_no`

`13`

表示当前记录在记录堆的位置信息

`record_type`

`3`

表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录

`next_record`

`16`

表示下一条记录的相对位置

大家不要被这么多的属性和陌生的概念给吓着，我这里只是为了内容的完整性把这些位代表的意思都写了出来，现在没必要把它们的意思都记住，记住也没啥用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看。

因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。所以我们现在直接看一下`record_format_demo`中的两条记录的`头信息`分别是什么：

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="309"></svg>)

> 小贴士： 再一次强调，大家如果看不懂记录头信息里各个位代表的概念千万别纠结，我们后边会说的～

#### 记录的真实数据

对于`record_format_demo`表来说，`记录的真实数据`除了`c1`、`c2`、`c3`、`c4`这几个我们自己定义的列的数据以外，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

列名

是否必须

占用空间

描述

`row_id`

否

`6`字节

行ID，唯一标识一条记录

`transaction_id`

是

`6`字节

事务ID

`roll_pointer`

是

`7`字节

回滚指针

> 小贴士： 实际上这几个列的真正名称其实是：DB\_ROW\_ID、DB\_TRX\_ID、DB\_ROLL\_PTR，我们为了美观才写成了row\_id、transaction\_id和roll_pointer。

这里需要提一下`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 _**transaction_id**_ 和 _**roll_pointer**_ 这两个列，但是 _**row_id**_ 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

因为表`record_format_demo`并没有定义主键，所以`MySQL`服务器会为每条记录增加上述的3个列。现在看一下加上`记录的真实数据`的两个记录长什么样吧：

![image_1c9h256f9nke14311adhtu61ie2dn.png-92kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1094" height="354"></svg>)

看这个图的时候我们需要注意几点：

1.  表`record_format_demo`使用的是`ascii`字符集，所以`0x61616161`就表示字符串`'aaaa'`，`0x626262`就表示字符串`'bbb'`，以此类推。
    
2.  注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在`ascii`字符集的表示就是`0x20`。
    
3.  注意第2条记录中`c3`和`c4`列的值都为`NULL`，它们被存储在了前边的`NULL值列表`处，在记录的真实数据处就不再冗余存储，从而节省存储空间。
    

#### CHAR(M)列的存储格式

`record_format_demo`表的`c1`、`c2`、`c4`列的类型是`VARCHAR(10)`，而`c3`列的类型是`CHAR(10)`，我们说在`Compact`行格式下只会把变长类型的列的长度逆序存到`变长字段长度列表`中，就像这样：

![image_1c9jdkga71kegkjs14o111ov1ce3kn.png-12.5kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="322" height="152"></svg>)

但是这只是因为我们的`record_format_demo`表采用的是`ascii`字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如`gbk`表示一个字符要1~2个字节、`utf8`表示一个字符要1~3个字节等）的话，`c3`列的长度也会被存储到`变长字段长度列表`中，比如我们修改一下`record_format_demo`表的字符集：

    mysql> ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
    Query OK, 2 rows affected (0.02 sec)
    Records: 2  Duplicates: 0  Warnings: 0
    

修改该列字符集后记录的`变长字段长度列表`也发生了变化，如图：

![image_1c9jeb6defgf1o981lgfciokjl4.png-43.1kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="545" height="459"></svg>)

这就意味着：对于 _**CHAR(M)**_ 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

另外有一点还需要注意，变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计`Compact`行格式的大叔既想节省存储空间，又不想更新`CHAR(M)`类型的列产生碎片时的纠结心情了吧。）

### Redundant行格式

其实知道了`Compact`行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的`Redundant`行格式是`MySQL5.0`之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。

画个图展示一下`Redundant`行格式的全貌：

![image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="618" height="251"></svg>)

现在我们把表`record_format_demo`的行格式修改为`Redundant`：

    mysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
    Query OK, 0 rows affected (0.05 sec)
    Records: 0  Duplicates: 0  Warnings: 0
    

为了方便大家理解和节省篇幅，我们直接把表`record_format_demo`在`Redundant`行格式下的两条记录的真实存储数据提供出来，之后我们着重分析两种行格式的不同即可。

![image_1c9h8tnav166c187m1nhap61153qgn.png-91.6kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1046" height="337"></svg>)

下边我们从各个方面看一下`Redundant`行格式有什么不同的地方：

*   字段长度偏移列表
    
    注意`Compact`行格式的开头是`变长字段长度列表`，而`Redundant`行格式的开头是`字段长度偏移列表`，与`变长字段长度列表`有两处不同：
    
    *   没有了变长两个字，意味着`Redundant`行格式会把该条记录中所有列（包括`隐藏列`）的长度信息都按照逆序存储到`字段长度偏移列表`。
        
    *   多了个偏移两个字，这意味着计算列值长度的方式不像`Compact`行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。
        
        比如第一条记录的`字段长度偏移列表`就是：
        
            25 24 1A 17 13 0C 06
            
        
        因为它是逆序排放的，所以按照列的顺序排列就是：
        
            06 0C 13 17 1A 24 25
            
        
        按照两个相邻数值的差值来计算各个列值的长度的意思就是：
        
            第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。
            
            第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。
            
            第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。
            
            第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。
            
            第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。
            
            第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。
            
            第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。
            
        
*   记录头信息
    
    `Redundant`行格式的记录头信息占用`6`字节，`48`个二进制位，这些二进制位代表的意思如下：
    
    名称
    
    大小（单位：bit）
    
    描述
    
    `预留位1`
    
    `1`
    
    没有使用
    
    `预留位2`
    
    `1`
    
    没有使用
    
    `delete_mask`
    
    `1`
    
    标记该记录是否被删除
    
    `min_rec_mask`
    
    `1`
    
    B+树的每层非叶子节点中的最小记录都会添加该标记
    
    `n_owned`
    
    `4`
    
    表示当前记录拥有的记录数
    
    `heap_no`
    
    `13`
    
    表示当前记录在页面堆的位置信息
    
    `n_field`
    
    `10`
    
    表示记录中列的数量
    
    `1byte_offs_flag`
    
    `1`
    
    标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的
    
    `next_record`
    
    `16`
    
    表示下一条记录的相对位置
    
    第一条记录中的头信息是：
    
        00 00 10 0F 00 BC
        
    
    根据这六个字节可以计算出各个属性的值，如下：
    
        预留位1：0x00
        预留位2：0x00
        delete_mask: 0x00
        min_rec_mask: 0x00
        n_owned: 0x00
        heap_no: 0x02
        n_field: 0x07
        1byte_offs_flag: 0x01
        next_record:0xBC
        
    
    与`Compact`行格式的记录头信息对比来看，有两处不同：
    
    *   `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。
        
    *   `Redundant`行格式没有`record_type`这个属性。
        
*   `1byte_offs_flag`的值是怎么选择的
    
    `字段长度偏移列表`实质上是存储每个列中的值占用的空间在`记录的真实数据`处结束的位置，还是拿`record_format_demo`第一条记录为例，`0x06`代表第一个列在`记录的真实数据`第6个字节处结束，`0x0C`代表第二个列在`记录的真实数据`第12个字节处结束，`0x13`代表第三个列在`记录的真实数据`第19个字节处结束，等等等等，最后一个列对应的偏移量值为`0x25`，也就意味着最后一个列在`记录的真实数据`第37个字节处结束，也就意味着整条记录的`真实数据`实际上占用`37`个字节。
    
    我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条`Redundant`行格式`记录的真实数据`占用的总大小来判断的：
    
    *   当记录的真实数据占用的字节数不大于127（十六进制`0x7F`，二进制`01111111`）时，每个列对应的偏移量占用1个字节。
    
    > 小贴士： 如果整个记录的真实数据占用的存储空间都不大于127个字节，那么每个列对应的偏移量值肯定也就不大于127，也就可以使用1个字节来表示喽。
    
    *   当记录的真实数据占用的字节数大于127，但不大于32767（十六进制`0x7FFF`，二进制`0111111111111111`）时，每个列对应的偏移量占用2个字节。
        
    *   有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前`768`个字节和20个字节的溢出页面地址（当然这20个字节中还记录了一些别的信息）。因为`字段长度偏移列表`处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。
        
    
    大家可以看出来，设计`Redundant`行格式的大叔还是比较简单粗暴的，直接使用整个`记录的真实数据`长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了～）。
    
    > 小贴士： 大家有没有疑惑，一个字节能表示的范围是0～255，为啥在记录的真实数据占用的存储空间大于127时就采用2个字节表示各个列的偏移量呢？稍安勿躁，后边马上揭晓。
    
    为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，设计`Redundant`行格式的大叔特意在`记录头信息`里放置了一个称之为`1byte_offs_flag`的属性：
    
    *   当它的值为1时，表明使用1个字节存储。
        
    *   当它的值为0时，表明使用2个字节存储。
        
*   `Redundant`行格式中`NULL`值的处理
    
    因为`Redundant`行格式并没有`NULL值列表`，所以设计`Redundant`行格式的大叔在`字段长度偏移列表`中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为`NULL`的依据，该比特位也可以被称之为`NULL比特位`。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的`NULL比特位`是不是为`1`，如果为`1`，那么该列的值就是`NULL`，否则不是`NULL`。
    
    这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制`0x7F`，二进制`01111111`）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的`NULL比特位`，用来标记该列的值是否为`NULL`。
    
    但是还有一点要注意，对于值为`NULL`的列来说，该列的类型是否为定长类型决定了`NULL`值的实际存储方式，我们接下来分析一下`record_format_demo`表的第二条记录，它对应的`字段长度偏移列表`如下：
    
        A4 A4 1A 17 13 0C 06
        
    
    按照列的顺序排放就是：
    
        06 0C 13 17 1A A4 A4
        
    
    我们分情况看一下：
    
    *   如果存储`NULL`值的字段是定长类型的，比方说`CHAR(M)`数据类型的，则`NULL`值也将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。
        
        如图第二条记录的`c3`列的值是`NULL`，而`c3`列的类型是`CHAR(10)`，占用记录的真实数据部分10字节，所以我们看到在`Redundant`行格式中使用`0x00000000000000000000`来表示`NULL`值。
        
        另外，`c3`列对应的偏移量为`0xA4`，它对应的二进制实际是：`10100100`，可以看到最高位为`1`，意味着该列的值是`NULL`。将最高位去掉后的值变成了`0100100`，对应的十进制值为`36`，而`c2`列对应的偏移量为`0x1A`，也就是十进制的`26`。`36 - 26 = 10`，也就是说最终`c3`列占用的存储空间为10个字节。
        
    *   如果该存储`NULL`值的字段是变长数据类型的，则不在`记录的真实数据`处占用任何存储空间。
        
        比如`record_format_demo`表的`c4`列是`VARCHAR(10)`类型的，`VARCHAR(10)`是一个变长数据类型，`c4`列对应的偏移量为`0xA4`，与`c3`列对应的偏移量相同，这也就意味着它的值也为`NULL`，将`0xA4`的最高位去掉后对应的十进制值也是`36`，`36 - 36 = 0`，也就意味着`c4`列本身不占用任何`记录的实际数据`处的空间。
        

除了以上的几点之外，`Redundant`行格式和`Compact`行格式还是大致相同的。

#### CHAR(M)列的存储格式

我们知道`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。比方说使用`utf8`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为`30`个字节，使用`gbk`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为`20`个字节。由此可以看出来，使用`Redundant`行格式的`CHAR(M)`类型的列是不会产生碎片的。

### 行溢出数据

#### VARCHAR(M)最多能存储的数据

我们知道对于`VARCHAR(M)`类型的列最多可以占用`65535`个字节。其中的`M`代表该类型最多存储的字符数量，如果我们使用`ascii`字符集的话，一个字符就代表一个字节，我们看看`VARCHAR(65535)`是否可用：

    mysql> CREATE TABLE varchar_size_demo(
        ->     c VARCHAR(65535)
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
    ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
    mysql>
    

从报错信息里可以看出，`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

*   真实数据
*   真实数据占用字节的长度
*   `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：

    mysql> CREATE TABLE varchar_size_demo(
        ->      c VARCHAR(65532)
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
    Query OK, 0 rows affected (0.02 sec)
    

如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度可能占用2个字节，不需要`NULL`值标识：

    mysql> DROP TABLE varchar_size_demo;
    Query OK, 0 rows affected (0.01 sec)
    
    mysql> CREATE TABLE varchar_size_demo(
        ->      c VARCHAR(65533) NOT NULL
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
    Query OK, 0 rows affected (0.02 sec)
    

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

    mysql> DROP TABLE varchar_size_demo;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> CREATE TABLE varchar_size_demo(
        ->       c VARCHAR(65532)
        -> ) CHARSET=gbk ROW_FORMAT=Compact;
    ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT instead
    
    mysql> CREATE TABLE varchar_size_demo(
        ->       c VARCHAR(65532)
        -> ) CHARSET=utf8 ROW_FORMAT=Compact;
    ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT instead
    

从执行结果中可以看出，如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为`NULL`的情况下，`gbk`字符集表示一个字符最多需要`2`个字节，那在该字符集下，`M`的最大取值就是`32766`（也就是：65532/2），也就是说最多能存储`32766`个字符；`utf8`字符集表示一个字符最多需要`3`个字节，那在该字符集下，`M`的最大取值就是`21844`，就是说最多能存储`21844`（也就是：65532/3）个字符。

> 小贴士： 上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！

#### 记录中的数据太多产生的溢出

我们以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

    mysql> CREATE TABLE varchar_size_demo(
        ->       c VARCHAR(65532)
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
    Query OK, 0 rows affected (0.01 sec)
    
    mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
    Query OK, 1 row affected (0.00 sec)
    

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1160" height="627"></svg>)

从图中可以看出来，对于`Compact`和`Reduntant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="951" height="213"></svg>)

最后需要注意的是，不只是 _**VARCHAR(M)**_ 类型的列，其他的 _**TEXT**_、_**BLOB**_ 类型的列在存储数据非常多的时候也会发生`行溢出`。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

*   每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`132`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。
    
*   每个记录需要的额外信息是`27`字节。
    
    这27个字节包括下边这些部分：
    
    *   2个字节用于存储真实数据的长度
    *   1个字节用于存储列是否是NULL值
    *   5个字节大小的头信息
    *   6个字节的`row_id`列
    *   6个字节的`transaction_id`列
    *   7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，设计`MySQL`的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：

    132 + 2×(27 + n) < 16384
    

求解这个式子得出的解是：`n < 8099`。也就是说如果一个列中存储的数据小于`8099`个字节，那么该列就不会成为`溢出列`，否则该列就需要成为`溢出列`。不过这个`8099`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为`溢出列`。

### Dynamic和Compressed行格式

下边要介绍另外两个行格式，`Dynamic`和`Compressed`行格式，我现在使用的`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="791" height="219"></svg>)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

总结
--

1.  页是`MySQL`中磁盘和内存交互的基本单位，也是`MySQL`是管理存储空间的基本单位。
    
2.  指定和修改行格式的语法如下：
    
        CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
        
        ALTER TABLE 表名 ROW_FORMAT=行格式名称
        
    
3.  `InnoDB`目前定义了4种行格式
    
    *   COMPACT行格式
        
        具体组成如图：
        
        ![image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="783" height="250"></svg>)
        
    *   Redundant行格式
        
        具体组成如图：
        
        ![image_1ctfppb4c1cng1m8718l91760jde9.png-36.2kB](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="618" height="251"></svg>)
        
    *   Dynamic和Compressed行格式
        
        这两种行格式类似于`COMPACT行格式`，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。
        
        另外，`Compressed`行格式会采用压缩算法对页面进行压缩。
        

*   一个页一般是`16KB`，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为`行溢出`。必须对应一个字符集。
    
4.  查看`MySQL`中查看支持的字符集和比较规则的语句如下：
    
        SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
        SHOW COLLATION [LIKE 匹配的模式];
        
    
5.  MySQL有四个级别的字符集和比较规则
    

*   服务器级别
    
    `character_set_server`表示服务器级别的字符集，`collation_server`表示服务器级别的比较规则。
    
*   数据库级别
    
    创建和修改数据库时可以指定字符集和比较规则：
    
        CREATE DATABASE 数据库名
            [[DEFAULT] CHARACTER SET 字符集名称]
            [[DEFAULT] COLLATE 比较规则名称];
        
        ALTER DATABASE 数据库名
            [[DEFAULT] CHARACTER SET 字符集名称]
            [[DEFAULT] COLLATE 比较规则名称];
        
    
    `character_set_database`表示当前数据库的字符集，`collation_database`表示当前默认数据库的比较规则，这两个系统变量是只读的，不能修改。如果没有指定当前默认数据库，则变量与相应的服务器级系统变量具有相同的值。
    
*   表级别
    
    创建和修改表的时候指定表的字符集和比较规则：
    
        CREATE TABLE 表名 (列的信息)
            [[DEFAULT] CHARACTER SET 字符集名称]
            [COLLATE 比较规则名称]];
        
        ALTER TABLE 表名
            [[DEFAULT] CHARACTER SET 字符集名称]
            [COLLATE 比较规则名称];
        
    
*   列级别
    
    创建和修改列定义的时候可以指定该列的字符集和比较规则：
    
        CREATE TABLE 表名(
            列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
            其他列...
        );
        
        ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
        
    

6.  从发送请求到接收结果过程中发生的字符集转换：
    
    *   客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。
        
    *   服务器将客户端发送来的字节串采用`character_set_client`代表的字符集进行解码，将解码后的字符串再按照`character_set_connection`代表的字符集进行编码。
        
    *   如果`character_set_connection`代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从`character_set_connection`代表的字符集转换为具体操作的列使用的字符集之后再进行操作。
        
    *   将从某个列获取到的字节串从该列使用的字符集转换为`character_set_results`代表的字符集后发送到客户端。
        
    *   客户端使用操作系统的字符集解析收到的结果集字节串。
        
    
    在这个过程中各个系统变量的含义如下：
    
    系统变量
    
    描述
    
    `character_set_client`
    
    服务器解码请求时使用的字符集
    
    `character_set_connection`
    
    服务器处理请求时会把请求字符串从`character_set_client`转为`character_set_connection`
    
    `character_set_results`
    
    服务器向客户端返回数据时使用的字符集
    
    一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。
    
7.  比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。